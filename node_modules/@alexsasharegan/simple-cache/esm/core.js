import { Option } from "safe-types";
export function create_rebalancer(c, capacity) {
    return function rebalance_cache(newKey) {
        // Sort items in ascending order of hits.
        let items = Array.from(c.values()).sort((a, b) => a.hits - b.hits);
        while (c.size > capacity) {
            // Pull items off the least accessed side of the array.
            // Use `!` to assert our value is not void.
            // Cache overflow tests verify we can trust this.
            let { key } = items.shift();
            // Guard against removing the item just written to the cache
            if (key == newKey) {
                continue;
            }
            c.delete(key);
        }
    };
}
function baseItemFactory(key, value) {
    return {
        key,
        value,
        hits: 0,
    };
}
/**
 * CoreCache implements a base set of the Cache interface's methods, while
 * providing a few extra methods to make composition more flexible to other
 * public Cache implementations.
 */
export function CoreCache(capacity, opts = {}) {
    if (capacity < 1 || !Number.isInteger(capacity)) {
        throw new RangeError(`Cache capacity requires an integer value greater than or equal to 1`);
    }
    let c = new Map();
    let rebalance = create_rebalancer(c, capacity);
    let { itemFactory = baseItemFactory } = opts;
    const cache = {
        get_store() {
            return c;
        },
        get(k) {
            return Option.of(cache.read(k));
        },
        read(k) {
            let item = c.get(k);
            if (!item) {
                return undefined;
            }
            item.hits += 1;
            return item.value;
        },
        write(k, v) {
            let item = itemFactory(k, v);
            let existing = c.get(k);
            if (existing) {
                // Writes that are updates should increment the hit count
                // rather than initialize it.
                item.hits += existing.hits;
            }
            c.set(k, item);
            if (c.size > capacity) {
                rebalance(k);
            }
        },
        remove(k) {
            c.delete(k);
        },
        invalidate() {
            cache.clear();
        },
        clear() {
            c.clear();
        },
        size() {
            return c.size;
        },
        keys() {
            return Array.from(c.keys());
        },
        values() {
            return Array.from(c.values(), x => x.value);
        },
        entries() {
            return Array.from(c.entries(), ([k, v]) => {
                // Strip out the internals
                // (TS cast is to preserve the correct tuple shape)
                return [k, v.value];
            });
        },
    };
    return cache;
}
//# sourceMappingURL=core.js.map