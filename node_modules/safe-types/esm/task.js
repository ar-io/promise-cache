var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Result } from "./result";
import { identity, noop } from "./utils";
/**
 * `Task<T, E>` represents a time-based operation that can resolve with success
 * or error value types `T` or `E` respectively.
 */
export class Task {
    /**
     * Construct a new Task by passing a function that performs the Task operation
     * itself. The function receives a `TaskResolver` object as it's first
     * argument. One of the resolver methods must be called or the Task will never
     * complete.
     */
    constructor(executor) {
        this.executor = executor;
    }
    /**
     * `fork` begins execution of the Task and returns a Promise resolving with a
     * `Result` that contains the the return value of your resolver object's
     * corresponding callback.
     */
    fork(resolver) {
        let { Ok: mapOk, Err: mapErr } = resolver;
        return new Promise((resolve) => this.executor({
            Ok: (okValue) => resolve(Result.Ok(mapOk(okValue))),
            Err: (errValue) => resolve(Result.Err(mapErr(errValue))),
        }));
    }
    /**
     * `run` begins execution of the Task and returns a Promise resolving with a
     * `Result` that contains the success or error value of the Task.
     */
    run() {
        return this.fork({
            Err: identity,
            Ok: identity,
        });
    }
    /**
     * Conforms to the Promise A+ spec.
     */
    then(onfulfilled, onrejected) {
        return this.try().then(onfulfilled, onrejected);
    }
    /**
     * `run_sync` executes the Task synchronously and returns a `Result` that
     * contains the success or error value of the Task.
     *
     * _NOTE: throws an Error if a callback is not invoked synchronously._
     */
    run_sync() {
        let r;
        // The executor is not guaranteed to return anything.
        // We need to use the callbacks to assign our Result.
        this.executor({
            Ok(value) {
                r = Result.Ok(value);
            },
            Err(err) {
                r = Result.Err(err);
            },
        });
        // The first bang `!` is for logical not, the second for definite assignment
        if (!r) {
            throw new Error(`Task.run_sync expects the executor to resolve synchronously.`);
        }
        // We've asserted that `r` is definitely assigned
        return r;
    }
    /**
     * `exec` immediately executes the task,
     * but discards the resolved value for both success and error cases.
     */
    exec() {
        this.executor({
            Ok: noop,
            Err: noop,
        });
    }
    /**
     * `try` runs a task and resolves with a success value,
     * or throws it's error value.
     */
    try() {
        return new Promise((Ok, Err) => {
            this.executor({ Ok, Err });
        });
    }
    /**
     * `tap` allows you to do side-effects with the value
     * when the Task is executed and is on the success path.
     *
     * Essentially a shorthand for doing a `Task.map()` that
     * returns the value it's called with after performing a side-effect.
     */
    tap(fn) {
        return this.map((ok) => {
            fn(ok);
            return ok;
        });
    }
    /**
     * `tap_err` allows you to do side-effects with the value
     * when the Task is executed and is on the error path.
     *
     * Essentially a shorthand for doing a `Task.map_err()` that
     * returns the value it's called with after performing a side-effect.
     */
    tap_err(fn) {
        return this.map_err((err) => {
            fn(err);
            return err;
        });
    }
    /**
     * `finally` allows you to run a side-effect function
     * in either Ok/Err cases, but does not receive a value.
     */
    finally(fn) {
        return new Task(({ Ok, Err }) => this.executor({
            Ok(ok) {
                fn();
                Ok(ok);
            },
            Err(err) {
                fn();
                Err(err);
            },
        }));
    }
    /**
     * `map` returns a new Task with the success value mapped according to the
     * map function given. `map` should be a synchronous operation.
     */
    map(op) {
        return new Task(({ Ok, Err }) => this.executor({
            Ok: (okValue) => Ok(op(okValue)),
            Err,
        }));
    }
    /**
     * `map_to` returns a new Task with the success value mapped to the static
     * value given.
     */
    map_to(value) {
        return this.map(() => value);
    }
    /**
     * `map_err` returns a new Task with the error value mapped according to the
     * map function given. `map` should be a synchronous operation.
     */
    map_err(op) {
        return new Task(({ Ok, Err }) => this.executor({
            Ok,
            Err: (errValue) => Err(op(errValue)),
        }));
    }
    /**
     * `map_err_to` returns a new Task with the success value mapped to the static
     * value given.
     */
    map_err_to(error) {
        return this.map_err(() => error);
    }
    /**
     * `map_both` returns a new Task that applies the map functions to either the
     * success case or the error case.
     */
    map_both(bimap) {
        return new Task(({ Ok, Err }) => this.executor({
            Ok: (okValue) => Ok(bimap.Ok(okValue)),
            Err: (errValue) => Err(bimap.Err(errValue)),
        }));
    }
    /**
     * `and` composes two Tasks such that `task_b` is forked only if the first
     * task resolves with a success. `task_b` must have the same error type as the
     * first task, but can return a new success type.
     */
    and(task_b) {
        return new Task(({ Ok, Err }) => this.executor({
            Ok: () => task_b.executor({ Ok, Err }),
            Err,
        }));
    }
    /**
     * `and_effect` will compose a Task such that the effect is only executed
     * if the first task resolves with a success. It will resolve with the
     * value of the first task and execute the effect task via `Task.exec`,
     * discarding it's return and leaving the task chain unaffected.
     */
    and_effect(effect) {
        return this.tap(() => {
            effect.exec();
        });
    }
    /**
     * `and_then` accepts a function that takes the success value of the first
     * Task and returns a new Task. This allows for sequencing tasks that depend
     * on the output of a previous task. The new Task must have the same error
     * type as the first task, but can return a new success type.
     */
    and_then(op) {
        return new Task(({ Ok, Err }) => this.executor({
            Ok: (okValue) => op(okValue).executor({ Ok, Err }),
            Err,
        }));
    }
    /**
     * `and_then_effect` will compose a Task such that the effect func is only
     * called and executed if the first task resolves with a success.
     * It will resolve with the value of the first task
     * and execute the effect task via `Task.exec`,
     * discarding it's return and leaving the task chain unaffected.
     *
     * **CAUTION:**
     * Mutating the value the effect func is called with will affect the chain.
     */
    and_then_effect(effect_fn) {
        return this.tap((x) => {
            effect_fn(x).exec();
        });
    }
    /**
     * `or` composes two Tasks such that `task_b` is forked only if the first Task
     * resolves with an error. `task_b` must have the same success type as the
     * first task, but can return a new error type.
     */
    or(task_b) {
        return new Task(({ Ok, Err }) => this.executor({
            Ok,
            Err: () => task_b.executor({ Ok, Err }),
        }));
    }
    /**
     * `or_effect` will compose a Task such that the effect is only executed
     * if the first task resolves with an error. It will resolve with the
     * value of the first task and execute the effect task via `Task.exec`,
     * discarding it's return and leaving the task chain unaffected.
     */
    or_effect(effect) {
        return this.tap_err(() => {
            effect.exec();
        });
    }
    /**
     * `or_else` accepts a function that takes the error value of the first Task
     * and returns a new Task. This allows for sequencing tasks in the case of
     * failure based on the output of a previous task. The new Task must have the
     * same success type as the first task, but can return a new error type.
     */
    or_else(op) {
        return new Task(({ Ok, Err }) => this.executor({
            Ok,
            Err: (errValue) => op(errValue).executor({ Ok, Err }),
        }));
    }
    /**
     * `or_else_effect` will compose a Task such that the effect func is only
     * called and executed if the first task resolves with an error.
     * It will resolve with the value of the first task
     * and execute the effect task via `Task.exec`,
     * discarding it's return and leaving the task chain unaffected.
     *
     * **CAUTION:**
     * Mutating the value the effect func is called with will affect the chain.
     */
    or_else_effect(effect_fn) {
        return this.tap_err((x) => {
            effect_fn(x).exec();
        });
    }
    /**
     * `invert` returns a new Task with the success and error cases swapped.
     */
    invert() {
        return new Task(({ Ok, Err }) => this.executor({
            Ok: Err,
            Err: Ok,
        }));
    }
    /**
     * Unlike `Result` and `Option` types which know their state and stringify, `Task` cannot
     * since it represent a future value. As such, it just behaves like a generic
     * object for stringify behavior:
     *
  ```
  '[object Task]'
  ```
     */
    toString() {
        return `[object Task]`;
    }
    /**
     * Construct a new Task by passing a function that performs the Task operation
     * itself. The function receives a `TaskResolver` object as it's first
     * argument. One of the resolver methods must be called or the Task will never
     * complete.
     */
    static from(executor) {
        return new Task(executor);
    }
    /**
     * Takes any number of tasks and returns a new Task that will run all tasks
     * concurrently. The first task to fail will trigger the rest to abort.
     */
    static all(tasks) {
        return new Task(({ Ok, Err }) => {
            Promise.all(tasks.map(task_all_executor)).then(Ok).catch(Err);
            function task_all_executor(t) {
                return new Promise((resolve, reject) => t.executor({
                    Ok: resolve,
                    Err: reject,
                }));
            }
        });
    }
    /**
     * Takes any number of tasks and returns a new Task that will run all tasks
     * with the specified concurrency.
     * The first task to fail will trigger the rest to abort.
     */
    static all_concurrent(options, tasks) {
        return new Task(({ Ok, Err }) => {
            let { concurrency } = options;
            let results = new Array(tasks.length);
            let completed = 0;
            let started = 0;
            let running = 0;
            let didError = false;
            replenish();
            function replenish() {
                if (completed >= tasks.length) {
                    return Ok(results);
                }
                while (running < concurrency && started < tasks.length && !didError) {
                    running++;
                    started++;
                    worker(started - 1);
                }
            }
            function worker(index) {
                tasks[index]
                    .tap((ok) => {
                    running--;
                    completed++;
                    results[index] = ok;
                    replenish();
                })
                    .tap_err((err) => {
                    didError = true;
                    Err(err);
                })
                    .exec();
            }
        });
    }
    /**
     * `collect` returns a new Task that will run an array of Tasks concurrently,
     * collecting all resolved values in a tuple of `[T[], E[]]`.
     *
     * **NOTE:** Order is not preserved. Always resolves `Ok`.
     */
    static collect(tasks) {
        return new Task(({ Ok }) => __awaiter(this, void 0, void 0, function* () {
            let running = tasks.length;
            let oks = [];
            let errs = [];
            if (running === 0) {
                Ok([oks, errs]);
            }
            let resolver = {
                Ok(okValue) {
                    oks.push(okValue);
                    running--;
                    if (running === 0) {
                        Ok([oks, errs]);
                    }
                },
                Err(errValue) {
                    errs.push(errValue);
                    running--;
                    if (running === 0) {
                        Ok([oks, errs]);
                    }
                },
            };
            for (let t of tasks) {
                t.executor(resolver);
            }
        }));
    }
    /**
     * `collect_concurrent` returns a new Task that will run an array of Tasks
     * with the specified concurrency,
     * collecting all resolved values in a tuple of `[T[], E[]]`.
     *
     * **NOTE:** Order is not preserved. Always resolves `Ok`.
     */
    static collect_concurrent(options, tasks) {
        return new Task(({ Ok }) => {
            let { concurrency } = options;
            let successes = [];
            let errors = [];
            let completed = 0;
            let started = 0;
            let running = 0;
            let resolver = {
                Ok(okValue) {
                    successes.push(okValue);
                    running--;
                    completed++;
                    replenish();
                },
                Err(errValue) {
                    errors.push(errValue);
                    running--;
                    completed++;
                    replenish();
                },
            };
            replenish();
            function replenish() {
                if (completed >= tasks.length) {
                    return Ok([successes, errors]);
                }
                while (running < concurrency && started < tasks.length) {
                    running++;
                    started++;
                    worker(tasks[started - 1]);
                }
            }
            function worker(t) {
                t.executor(resolver);
            }
        });
    }
    /**
     * `of_ok` constructs a Task that resolves with a success of the given value.
     */
    static of_ok(okValue) {
        return new Task(({ Ok }) => Ok(okValue));
    }
    /**
     * `of_err` constructs a Task that resolves with an error of the given value.
     */
    static of_err(errValue) {
        return new Task(({ Err }) => Err(errValue));
    }
    /**
     * Wraps a Task in another Task that will be run until success
     * up to the given limit of tries.
     */
    static retry(tryLimit, task) {
        if (tryLimit < 1 || !Number.isInteger(tryLimit)) {
            throw new RangeError(`Task.retry must use an integer try limit greater than zero`);
        }
        if (tryLimit === 1) {
            return task;
        }
        return new Task(({ Ok, Err }) => __awaiter(this, void 0, void 0, function* () {
            let r;
            for (let i = 0; i < tryLimit; i++) {
                r = yield task.run();
                if (r.is_ok()) {
                    break;
                }
            }
            r.match({ Ok, Err });
        }));
    }
    /**
     * Wraps a Task in another Task that will be run until success
     * up to the given limit of tries. After a failed run, exponential backoff
     * is calculated to wait before the next run. Uses exponential backoff
     * with equal jitter.
     */
    static retryWithBackoff(options, task) {
        let { msBackoffCap, tryLimit, msBackoffStep } = options;
        if (tryLimit < 1 || !Number.isInteger(tryLimit)) {
            throw new RangeError(`Task.retry must use an integer retry number greater than zero`);
        }
        if (tryLimit === 1) {
            return task;
        }
        function* backoff() {
            let retries = tryLimit - 1;
            for (let i = 0; i < retries; i++) {
                let equalBackoff = Math.min(msBackoffCap, msBackoffStep * Math.pow(2, i)) / 2;
                let jitter = Math.random() * equalBackoff;
                yield equalBackoff + jitter;
            }
        }
        return new Task(({ Ok, Err }) => __awaiter(this, void 0, void 0, function* () {
            let r = yield task.run();
            if (r.is_ok()) {
                return Ok(r.unwrap());
            }
            for (let ms of backoff()) {
                yield new Promise((next) => setTimeout(next, ms));
                r = yield task.run();
                if (r.is_ok()) {
                    break;
                }
            }
            r.match({ Ok, Err });
        }));
    }
}
//# sourceMappingURL=task.js.map