var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Err } from "./err";
import { Option } from "./index";
import { Ok } from "./ok";
import { always_false, always_true, expect_never, identity, noop, } from "./utils";
import { ResultVariant } from "./variant";
import { Task } from "./task";
/**
 * Result is a wrapper type for operations that can succeed or fail.
 * Not all operations throw errors in failure cases. Any value can be an Err.
 * Result simultaneously holds either an `Ok` that holds any type
 * and and `Err` that also can hold any type.
 */
export class Result {
    /**
     * Warning!
     * --------
     *
     * You should never construct a Result object manually. Use the `Ok` and `Err`
     * helpers to create a Result object from a value.
     */
    constructor(result) {
        this.result = result;
    }
    /**
     * Perform a pseudo pattern match on the underlying Ok or Err type.
     * Matches the type and then returns the value of calling the matcher's
     * function with the value.
     */
    match(matcher) {
        switch (this.result.variant) {
            default:
                return expect_never(this.result, "Invalid `Result` variant");
            case ResultVariant.Ok:
                return matcher.Ok(this.result.value);
            case ResultVariant.Err:
                return matcher.Err(this.result.error);
        }
    }
    /**
     * Returns true if the underlying type is an Ok.
     *
     * ```
     * let result = Ok(2)
     * result.is_ok()
     * // => true
     * ```
     */
    is_ok() {
        return this.match({
            Ok: always_true,
            Err: always_false,
        });
    }
    /**
     * Returns true if the underlying type is an Err.
     *
     * ```
     * let result = Ok(2)
     * result.is_err()
     * // => false
     * ```
     */
    is_err() {
        return !this.is_ok();
    }
    /**
     * Returns an Option of the Ok type.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.ok()
     * // => Option<string>
     * ```
     */
    ok() {
        return this.match({
            Ok: Option.Some,
            Err: Option.None,
        });
    }
    /**
     * Returns an Option of the Err type.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.err()
     * // => Option<Error>
     * ```
     */
    err() {
        return this.match({
            Ok: Option.None,
            Err: Option.Some,
        });
    }
    /**
     * Converts a result to a Task.
     * When the Result is Ok, forking the Task yields the Ok value.
     * When the Result is Err, forking the Task yields the Err value.
     */
    task() {
        return this.match({
            Ok: Task.of_ok,
            Err: Task.of_err,
        });
    }
    /**
     * `tap` allows you to do side-effects with the value
     * when `Result` is `Ok<T>`.
     */
    tap(fn) {
        this.match({ Err: noop, Ok: fn });
        return this;
    }
    /**
     * `tap_err` allows you to do side-effects with the value
     * when `Result` is `Err<E>`.
     */
    tap_err(fn) {
        this.match({ Err: fn, Ok: noop });
        return this;
    }
    /**
     * Perform a transformation on the possible Ok type.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.map(str => str.length)
     * // => Result<number, Error>
     * ```
     */
    map(op) {
        return this.match({
            Ok: (t) => Result.Ok(op(t)),
            Err: Result.Err,
        });
    }
    /**
     * `map_to` converts the inner value when Ok.
     */
    map_to(value) {
        return this.map(() => value);
    }
    /**
     * Perform a transformation on the possible Err type.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.map_err(err => err.message)
     * // => Result<string, string>
     * ```
     */
    map_err(op) {
        return this.match({
            Ok: Result.Ok,
            Err: (e) => Result.Err(op(e)),
        });
    }
    /**
     * `map_err_to` converts the inner value when Err.
     */
    map_err_to(error) {
        return this.map_err(() => error);
    }
    /**
     * Perform transformations on both of the possible types.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.map_both(console.log, console.error)
     * // => Result<void, void>
     * // => prints to stdout/stderr
     * ```
     */
    map_both(ok_op, err_op) {
        return this.match({
            Ok: (t) => Result.Ok(ok_op(t)),
            Err: (e) => Result.Err(err_op(e)),
        });
    }
    /**
     * Swaps the result's Ok type with the given result if Ok.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.and(readFileSync("bar.txt"))
     * // => Result<string, Error>
     * ```
     */
    and(res) {
        return this.match({
            Ok: () => res,
            Err: Result.Err,
        });
    }
    /**
     * Swaps the result's Ok type with the given Promised result if Ok
     * and normalizes the possible Err type to a Promised Err.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.and_await(readFile("bar.txt"))
     * // => Promise<Result<string, Error>>
     * ```
     */
    and_await(res) {
        return this.match({
            Ok: () => res,
            Err: (e) => Promise.resolve(Result.Err(e)),
        });
    }
    /**
     * Calls the given operation and swaps the Ok type if Ok.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.and_then(contents => readFileSync(contents.match(/\.txt$/)[1]))
     * // => Result<string, Error>
     * ```
     */
    and_then(op) {
        return this.match({
            Ok: (t) => op(t),
            Err: Result.Err,
        });
    }
    /**
     * Calls the given operation and swaps the Ok type with the promised Ok.
     * Err type is converted to a Promised Err.
     *
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.and_then(contents => readFile(contents.match(/\.txt$/)[1]))
     * // => Promise<Result<string, Error>>
     * ```
     */
    and_then_await(op) {
        return this.match({
            Ok: op,
            Err: (e) => Promise.resolve(Result.Err(e)),
        });
    }
    /**
     * Returns `res` if the result is [`Err`],
     * otherwise returns the [`Ok`] value of `self`.
     *
     * Arguments passed to `or` are eagerly evaluated; if you are passing the
     * result of a function call, it is recommended to use [`or_else`], which is
     * lazily evaluated.
     *
     * ```
     * let x = Ok(2);
     * let y = Err("late error");
     * expect(x.or(y)).toEqual(Ok(2));
     *
     * let x = Err("early error");
     * let y = Ok(2);
     * expect(x.or(y)).toEqual(Ok(2));
     *
     * let x = Err("not a 2");
     * let y = Err("late error");
     * expect(x.or(y)).toEqual(Err("late error"));
     *
     * let x = Ok(2);
     * let y = Ok(100);
     * expect(x.or(y)).toEqual(Ok(2));
     * ```
     */
    or(res) {
        return this.match({
            Ok: Result.Ok,
            Err: () => res,
        });
    }
    /**
     * Returns the given promised result if the result an Err, or else wraps the
     * existing result in a promise.
     */
    or_await(res) {
        return this.match({
            Ok: (val) => Promise.resolve(Result.Ok(val)),
            Err: () => res,
        });
    }
    /**
     * Calls `op` if the result is [`Err`],
     * otherwise returns the [`Ok`] value of `self`.
     *
     * This function can be used for control flow based on result values.
     *
     * ```
     * let sq = (x: number) => Ok(x * x)
     * let err = (x: number) => Err(x)
     *
     * expect(Ok(2).or_else(sq).or_else(sq)).toEqual(Ok(2));
     * expect(Ok(2).or_else(err).or_else(sq)).toEqual(Ok(2));
     * expect(Err(3).or_else(sq).or_else(err)).toEqual(Ok(9));
     * expect(Err(3).or_else(err).or_else(err)).toEqual(Err(3));
     * ```
     */
    or_else(op) {
        return this.match({
            Ok: Result.Ok,
            Err: op,
        });
    }
    /**
     * Calls the given function if the result an Err, or else wraps the
     * existing result in a promise.
     */
    or_else_await(op) {
        return this.match({
            Ok: (val) => Promise.resolve(Result.Ok(val)),
            Err: op,
        });
    }
    /**
     * Unwraps a result, yielding the content of an [`Ok`].
     * Else, it returns `optb`.
     *
     * Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing
     * the result of a function call, it is recommended to use [`unwrap_or_else`],
     * which is lazily evaluated.
     *
     * ```
     * let optb = 2;
     * let x: Result<number, string> = Ok(9);
     * expect(x.unwrap_or(optb)).toEqual(9);
     *
     * let x: Result<number, string> = Err("error");
     * expect(x.unwrap_or(optb)).toEqual(optb);
     * ```
     */
    unwrap_or(optb) {
        return this.match({
            Ok: identity,
            Err: () => optb,
        });
    }
    /**
     * Unwraps a result, yielding the content of an [`Ok`].
     * If the value is an [`Err`] then it calls `op` with its value.
     *
     * ```
     * let count = (x: string) => x.length;
     *
     * expect(Ok(2).unwrap_or_else(count)).toEqual(2);
     * expect(Err("foo").unwrap_or_else(count)).toEqual(3);
     * ```
     */
    unwrap_or_else(op) {
        return this.match({
            Ok: identity,
            Err: op,
        });
    }
    /**
     * Returns the Ok type, or throws an Error.
     */
    unwrap() {
        return this.match({
            Ok: identity,
            Err: () => {
                throw new Error(`Called 'Result.unwrap()' on ${this.toString()}`);
            },
        });
    }
    /**
     * Returns the Err type, or throws an Error.
     */
    unwrap_err() {
        return this.match({
            Ok: () => {
                throw new Error(`Called 'Result.unwrap_err()' on ${this.toString()}`);
            },
            Err: identity,
        });
    }
    /**
     * Returns the Ok type, or throws an Error with the given message.
     */
    expect(msg) {
        return this.match({
            Ok: identity,
            Err() {
                throw new Error(msg);
            },
        });
    }
    /**
     * Returns the Ok type, or throws the raw Err value.
     */
    try() {
        return this.match({
            Ok: identity,
            Err(error) {
                throw error;
            },
        });
    }
    /**
     * Returns the Err type, or throws an Error with the given message.
     */
    expect_err(msg) {
        return this.match({
            Ok() {
                throw new Error(msg);
            },
            Err: identity,
        });
    }
    /**
     * Remaps the result types so the `Ok<T>` becomes `Err<T>`
     * and the `Err<E>` becomes `Ok<E>`
     */
    invert() {
        return this.match({
            Ok: Result.Err,
            Err: Result.Ok,
        });
    }
    toString() {
        return this.match({
            Ok: (t) => `Ok<${JSON.stringify(t)}>`,
            Err: (e) => `Err<${JSON.stringify(e)}>`,
        });
    }
    /**
     * Returns an Ok result of the given type.
     */
    static Ok(val) {
        return new Result(Ok(val));
    }
    /**
     * Returns an Err result of the given type.
     */
    static Err(err) {
        return new Result(Err(err));
    }
    /**
     * Calls the operation and returns an Ok result
     * or an Err result if an Error is thrown.
     */
    static from(op) {
        try {
            return Result.Ok(op());
        }
        catch (e) {
            return Result.Err(e);
        }
    }
    /**
     * Calls the operation and returns an Ok result
     * or an Err result if an Error is thrown.
     */
    static of(op) {
        return Result.from(op);
    }
    /**
     * Given an array shaped `Result<T, E>[]`, returns a Result of all the
     * unwrapped values or the first Err.
     * Eager return (returns upon first Err case).
     */
    static every(results) {
        let r;
        let ok = [];
        let error;
        const matcher = {
            Ok: (t) => ok.push(t),
            Err: (e) => {
                error = e;
                return 0;
            },
        };
        for (r of results) {
            if (0 == r.match(matcher)) {
                return Result.Err(error);
            }
        }
        return Result.Ok(ok);
    }
    /**
     * Given an array shaped `Result<T, E>[]`, returns a Result of any the
     * unwrapped values or an Err with the all of the Err values.
     */
    static some(results) {
        if (results.length == 0) {
            return Result.Ok([]);
        }
        let ok = [];
        let err = [];
        let r;
        const matcher = {
            Ok: (t) => ok.push(t),
            Err: (e) => err.push(e),
        };
        for (r of results) {
            r.match(matcher);
        }
        // Any Ok's triggers a success.
        if (ok.length > 0) {
            return Result.Ok(ok);
        }
        return Result.Err(err);
    }
    /**
     * Awaits the Promise and returns a Promised Ok result
     * or a Promised Err result if an Error is thrown.
     */
    static await(p) {
        return Promise.resolve(p).then(Result.Ok, Result.Err);
    }
    /**
     * Calls the async operation and returns a Promised Ok result
     * or a Promised Err result if an Error is thrown.
     */
    static await_fn(op) {
        try {
            return Promise.resolve(op()).then(Result.Ok, Result.Err);
        }
        catch (error) {
            return Promise.resolve(Result.Err(error));
        }
    }
    /**
     * Awaits an array of Promises and returns a Promised Ok result
     * or a Promised Err result if an Error is thrown.
     */
    static await_all(ps) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all(ps).then(Result.Ok, Result.Err);
        });
    }
    /**
     * Calls the async operation and returns a Promised Ok result
     * or a Promised Err result if an Error is thrown.
     */
    static await_all_fn(op) {
        try {
            return Promise.all(op()).then(Result.Ok, Result.Err);
        }
        catch (error) {
            return Promise.resolve(Result.Err(error));
        }
    }
}
//# sourceMappingURL=result.js.map