import { Result } from "./result";
import { Mapper } from "./utils";
/**
 * `TaskResolver` is an object that implements the `Ok` and `Err` callback
 * methods. `Ok` should be called with the success value type `T`, while `Err`
 * should be called with the failure value type `E`. The handler callbacks
 * can each return different value types.
 */
export declare type TaskResolver<OkType, ErrType, OkOutput, ErrOutput> = {
    Ok: (ok: OkType) => OkOutput;
    Err: (err: ErrType) => ErrOutput;
};
/**
 * `TaskExecutorFunc` is the Task operation itself. It receives the
 * `TaskResolver` object as it's first argument. One of the resolver methods
 * must be called or the Task will never complete.
 */
export declare type TaskExecutorFunc<OkType, ErrType> = (resolver: TaskResolver<OkType, ErrType, any, any>) => any;
export declare type UnwrapTaskOk<T> = T extends Task<infer U, any> ? U : never;
export declare type UnwrapTaskErr<T> = T extends Task<any, infer E> ? E : never;
/**
 * `Task<T, E>` represents a time-based operation that can resolve with success
 * or error value types `T` or `E` respectively.
 */
export declare class Task<OkType, ErrType> implements PromiseLike<OkType> {
    executor: TaskExecutorFunc<OkType, ErrType>;
    /**
     * Construct a new Task by passing a function that performs the Task operation
     * itself. The function receives a `TaskResolver` object as it's first
     * argument. One of the resolver methods must be called or the Task will never
     * complete.
     */
    constructor(executor: TaskExecutorFunc<OkType, ErrType>);
    /**
     * `fork` begins execution of the Task and returns a Promise resolving with a
     * `Result` that contains the the return value of your resolver object's
     * corresponding callback.
     */
    fork<OkOutput, ErrOutput>(resolver: TaskResolver<OkType, ErrType, OkOutput, ErrOutput>): Promise<Result<OkOutput, ErrOutput>>;
    /**
     * `run` begins execution of the Task and returns a Promise resolving with a
     * `Result` that contains the success or error value of the Task.
     */
    run(): Promise<Result<OkType, ErrType>>;
    /**
     * Conforms to the Promise A+ spec.
     */
    then<TResult1 = OkType, TResult2 = never>(onfulfilled?: ((value: OkType) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * `run_sync` executes the Task synchronously and returns a `Result` that
     * contains the success or error value of the Task.
     *
     * _NOTE: throws an Error if a callback is not invoked synchronously._
     */
    run_sync(): Result<OkType, ErrType>;
    /**
     * `exec` immediately executes the task,
     * but discards the resolved value for both success and error cases.
     */
    exec(): void;
    /**
     * `try` runs a task and resolves with a success value,
     * or throws it's error value.
     */
    try(): Promise<OkType>;
    /**
     * `tap` allows you to do side-effects with the value
     * when the Task is executed and is on the success path.
     *
     * Essentially a shorthand for doing a `Task.map()` that
     * returns the value it's called with after performing a side-effect.
     */
    tap(fn: (ok: OkType) => any): Task<OkType, ErrType>;
    /**
     * `tap_err` allows you to do side-effects with the value
     * when the Task is executed and is on the error path.
     *
     * Essentially a shorthand for doing a `Task.map_err()` that
     * returns the value it's called with after performing a side-effect.
     */
    tap_err(fn: (err: ErrType) => any): Task<OkType, ErrType>;
    /**
     * `finally` allows you to run a side-effect function
     * in either Ok/Err cases, but does not receive a value.
     */
    finally(fn: () => any): Task<OkType, ErrType>;
    /**
     * `map` returns a new Task with the success value mapped according to the
     * map function given. `map` should be a synchronous operation.
     */
    map<MappedOk>(op: Mapper<OkType, MappedOk>): Task<MappedOk, ErrType>;
    /**
     * `map_to` returns a new Task with the success value mapped to the static
     * value given.
     */
    map_to<OkValue>(value: OkValue): Task<OkValue, ErrType>;
    /**
     * `map_err` returns a new Task with the error value mapped according to the
     * map function given. `map` should be a synchronous operation.
     */
    map_err<MappedErr>(op: Mapper<ErrType, MappedErr>): Task<OkType, MappedErr>;
    /**
     * `map_err_to` returns a new Task with the success value mapped to the static
     * value given.
     */
    map_err_to<ErrValue>(error: ErrValue): Task<OkType, ErrValue>;
    /**
     * `map_both` returns a new Task that applies the map functions to either the
     * success case or the error case.
     */
    map_both<MappedOk, MappedErr>(bimap: TaskResolver<OkType, ErrType, MappedOk, MappedErr>): Task<MappedOk, MappedErr>;
    /**
     * `and` composes two Tasks such that `task_b` is forked only if the first
     * task resolves with a success. `task_b` must have the same error type as the
     * first task, but can return a new success type.
     */
    and<NextOkType>(task_b: Task<NextOkType, ErrType>): Task<NextOkType, ErrType>;
    /**
     * `and_effect` will compose a Task such that the effect is only executed
     * if the first task resolves with a success. It will resolve with the
     * value of the first task and execute the effect task via `Task.exec`,
     * discarding it's return and leaving the task chain unaffected.
     */
    and_effect(effect: Task<any, any>): Task<OkType, ErrType>;
    /**
     * `and_then` accepts a function that takes the success value of the first
     * Task and returns a new Task. This allows for sequencing tasks that depend
     * on the output of a previous task. The new Task must have the same error
     * type as the first task, but can return a new success type.
     */
    and_then<NextOkType>(op: (ok: OkType) => Task<NextOkType, ErrType>): Task<NextOkType, ErrType>;
    /**
     * `and_then_effect` will compose a Task such that the effect func is only
     * called and executed if the first task resolves with a success.
     * It will resolve with the value of the first task
     * and execute the effect task via `Task.exec`,
     * discarding it's return and leaving the task chain unaffected.
     *
     * **CAUTION:**
     * Mutating the value the effect func is called with will affect the chain.
     */
    and_then_effect(effect_fn: (ok: OkType) => Task<any, any>): Task<OkType, ErrType>;
    /**
     * `or` composes two Tasks such that `task_b` is forked only if the first Task
     * resolves with an error. `task_b` must have the same success type as the
     * first task, but can return a new error type.
     */
    or<NextErrType>(task_b: Task<OkType, NextErrType>): Task<OkType, NextErrType>;
    /**
     * `or_effect` will compose a Task such that the effect is only executed
     * if the first task resolves with an error. It will resolve with the
     * value of the first task and execute the effect task via `Task.exec`,
     * discarding it's return and leaving the task chain unaffected.
     */
    or_effect(effect: Task<any, any>): Task<OkType, ErrType>;
    /**
     * `or_else` accepts a function that takes the error value of the first Task
     * and returns a new Task. This allows for sequencing tasks in the case of
     * failure based on the output of a previous task. The new Task must have the
     * same success type as the first task, but can return a new error type.
     */
    or_else<NextErrType>(op: (err: ErrType) => Task<OkType, NextErrType>): Task<OkType, NextErrType>;
    /**
     * `or_else_effect` will compose a Task such that the effect func is only
     * called and executed if the first task resolves with an error.
     * It will resolve with the value of the first task
     * and execute the effect task via `Task.exec`,
     * discarding it's return and leaving the task chain unaffected.
     *
     * **CAUTION:**
     * Mutating the value the effect func is called with will affect the chain.
     */
    or_else_effect(effect_fn: (err: ErrType) => Task<any, any>): Task<OkType, ErrType>;
    /**
     * `invert` returns a new Task with the success and error cases swapped.
     */
    invert(): Task<ErrType, OkType>;
    /**
     * Unlike `Result` and `Option` types which know their state and stringify, `Task` cannot
     * since it represent a future value. As such, it just behaves like a generic
     * object for stringify behavior:
     *
  ```
  '[object Task]'
  ```
     */
    toString(): string;
    /**
     * Construct a new Task by passing a function that performs the Task operation
     * itself. The function receives a `TaskResolver` object as it's first
     * argument. One of the resolver methods must be called or the Task will never
     * complete.
     */
    static from<OkType, ErrType>(executor: TaskExecutorFunc<OkType, ErrType>): Task<OkType, ErrType>;
    /**
     * Takes any number of tasks and returns a new Task that will run all tasks
     * concurrently. The first task to fail will trigger the rest to abort.
     */
    static all<OkType, ErrType>(tasks: Task<OkType, ErrType>[]): Task<OkType[], ErrType>;
    /**
     * Takes any number of tasks and returns a new Task that will run all tasks
     * with the specified concurrency.
     * The first task to fail will trigger the rest to abort.
     */
    static all_concurrent<OkType, ErrType>(options: {
        concurrency: number;
    }, tasks: Task<OkType, ErrType>[]): Task<OkType[], ErrType>;
    /**
     * `collect` returns a new Task that will run an array of Tasks concurrently,
     * collecting all resolved values in a tuple of `[T[], E[]]`.
     *
     * **NOTE:** Order is not preserved. Always resolves `Ok`.
     */
    static collect<OkType, ErrType>(tasks: Task<OkType, ErrType>[]): Task<[OkType[], ErrType[]], never>;
    /**
     * `collect_concurrent` returns a new Task that will run an array of Tasks
     * with the specified concurrency,
     * collecting all resolved values in a tuple of `[T[], E[]]`.
     *
     * **NOTE:** Order is not preserved. Always resolves `Ok`.
     */
    static collect_concurrent<OkType, ErrType>(options: {
        concurrency: number;
    }, tasks: Task<OkType, ErrType>[]): Task<[OkType[], ErrType[]], never>;
    /**
     * `of_ok` constructs a Task that resolves with a success of the given value.
     */
    static of_ok<OkType>(okValue: OkType): Task<OkType, any>;
    /**
     * `of_err` constructs a Task that resolves with an error of the given value.
     */
    static of_err<ErrType>(errValue: ErrType): Task<any, ErrType>;
    /**
     * Wraps a Task in another Task that will be run until success
     * up to the given limit of tries.
     */
    static retry<OkType, ErrType>(tryLimit: number, task: Task<OkType, ErrType>): Task<OkType, ErrType>;
    /**
     * Wraps a Task in another Task that will be run until success
     * up to the given limit of tries. After a failed run, exponential backoff
     * is calculated to wait before the next run. Uses exponential backoff
     * with equal jitter.
     */
    static retryWithBackoff<OkType, ErrType>(options: RetryWithBackoffOptions, task: Task<OkType, ErrType>): Task<OkType, ErrType>;
}
export interface RetryWithBackoffOptions {
    /**
     * Maximum number of runs to perform if Task is not successful.
     */
    tryLimit: number;
    /**
     * The average amount of backoff
     * by which to increase waits between retries (milliseconds).
     */
    msBackoffStep: number;
    /**
     * The maximum wait time between retries (milliseconds).
     */
    msBackoffCap: number;
}
