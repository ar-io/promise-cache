"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Option = void 0;
const index_1 = require("./index");
const none_1 = require("./none");
const some_1 = require("./some");
const utils_1 = require("./utils");
const variant_1 = require("./variant");
/**
 * Option is a wrapper type for nullable values (`undefined|null`). `Option.of`
 * will consume a nullable value `T` into an `Option<T>` for conducting safe
 * operations using all the class' combinators.
 */
class Option {
    /**
     * Warning!
     * --------
     *
     * You should never construct an Option object manually. Use the `Some` and
     * `None` helpers to create an Option object from a value or nothing.
     */
    constructor(option) {
        this.option = option;
    }
    match(matcher) {
        switch (this.option.variant) {
            default:
                return utils_1.expect_never(this.option, "invalid Option variant");
            case variant_1.OptionVariant.None:
                return matcher.None();
            case variant_1.OptionVariant.Some:
                return matcher.Some(this.option.value);
        }
    }
    /**
     * Returns `true` if the option is a [`Some`] value.
     *
     * ```
     * let x: Option<number> = Some(2);
     * expect(x.is_some()).toBe(true);
     *
     * let x: Option<number> = None();
     * expect(x.is_some()).toBe(false);
     * ```
     */
    is_some() {
        return this.match({
            Some: utils_1.always_true,
            None: utils_1.always_false,
        });
    }
    /**
     * Returns `true` if the option is a [`None`] value.
     *
     * ```
     * let x: Option<number> = Some(2);
     * expect(x.is_some()).toBe(false);
     *
     * let x: Option<number> = None();
     * expect(x.is_some()).toBe(true);
     * ```
     */
    is_none() {
        return !this.is_some();
    }
    /**
     * Returns the wrapped Some value or throws an Error
     * with the given message.
     */
    expect(msg) {
        return this.match({
            Some: utils_1.identity,
            None() {
                throw new Error(msg);
            },
        });
    }
    /**
     * Returns the wrapped Some value or throws an Error.
     */
    unwrap() {
        return this.match({
            Some: utils_1.identity,
            None: () => {
                throw new Error(`Called 'Option.unwrap()' on ${this.toString()}`);
            },
        });
    }
    /**
     * Returns the wrapped Some value or the given default.
     */
    unwrap_or(def) {
        return this.match({
            Some: utils_1.identity,
            None: () => def,
        });
    }
    /**
     * Returns the wrapped Some value
     * or calls and returns the result of the given func.
     */
    unwrap_or_else(fn) {
        return this.match({
            Some: utils_1.identity,
            None: fn,
        });
    }
    /**
     * Returns `None` if the option is `None`, otherwise calls `predicate`
     * with the wrapped value and returns:
     * - `Some(t)` if `predicate` returns `true` (where `t` is the wrapped
     * value), and
     * - `None` if `predicate` returns `false`.
     *
     * ```
     * let is_even = (n: number) => n % 2 == 0
     *
     * expect(None().filter(is_even)).toEqual(None());
     * expect(Some(3).filter(is_even)).toEqual(None());
     * expect(Some(4).filter(is_even)).toEqual(Some(4));
     * ```
     */
    filter(predicate) {
        return this.match({
            None: Option.None,
            Some: (value) => {
                if (!predicate(value)) {
                    return Option.None();
                }
                return Option.Some(value);
            },
        });
    }
    /**
     * `narrow` accepts a TypeScript type guard to narrow the generic type
     * held within `Option<T>`.
     */
    narrow(predicate) {
        return this.match({
            None: Option.None,
            Some: (value) => {
                if (!predicate(value)) {
                    return Option.None();
                }
                return Option.Some(value);
            },
        });
    }
    /**
     * Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to
     * [`Ok(v)`] and [`None`] to [`Err(err)`].
     *
     * Arguments passed to `ok_or` are eagerly evaluated; if you are passing the
     * result of a function call, it is recommended to use [`ok_or_else`], which is
     * lazily evaluated.
     *
     * ```
     * let x = Some("foo");
     * expect(x.ok_or(0)).toEqual(Ok("foo"));
     *
     * let x: Option<string> = None();
     * expect(x.ok_or(0)).toEqual(Err(0));
     * ```
     */
    ok_or(err) {
        return this.match({
            Some: index_1.Result.Ok,
            None: () => index_1.Result.Err(err),
        });
    }
    /**
     * Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to
     * [`Ok(v)`] and [`None`] to [`Err(err())`].
     *
     * ```
     * let x = Some("foo");
     * expect(x.ok_or_else(() => Err(0))).toEqual(Ok("foo"));
     *
     * let x: Option<string> = None;
     * expect(x.ok_or_else(() => Err(0)).toEqual(Err(0));
     * ```
     */
    ok_or_else(err) {
        return this.match({
            Some: index_1.Result.Ok,
            None: () => index_1.Result.Err(err()),
        });
    }
    /**
     * `tap` allows you to do side-effects with the value
     * when `Option` is `Some<T>`.
     */
    tap(fn) {
        this.match({ None: utils_1.noop, Some: fn });
        return this;
    }
    /**
     * Safely transform the wrapped Some value from `T` => `U`.
     *
     * ```
     * // Transform Option<string> => Option<number>
     * Option.of(maybeStr).map(str => str.trim().length)
     * ```
     */
    map(fn) {
        return this.match({
            Some: (x) => Option.Some(fn(x)),
            None: Option.None,
        });
    }
    /**
     * `map_to` transforms the inner value when Some.
     */
    map_to(value) {
        return this.map(() => value);
    }
    /**
     * Safely transform the wrapped Some value from `T` => `U`
     * and return the transformed value or a default if wrapped value is None.
     */
    map_or(def, fn) {
        return this.match({
            Some: fn,
            None: () => def,
        });
    }
    /**
     * Safely transform the wrapped Some value from `T` => `U`
     * and return the transformed value
     * or call a func to return a default if wrapped value is None.
     */
    map_or_else(def, fn) {
        return this.match({
            Some: fn,
            None: def,
        });
    }
    /**
     * Returns [`None`] if the option is [`None`], otherwise returns `optb`.
     *
     * ```
     * let x = Some(2);
     * let y: Option<string> = None();
     * expect(x.and(y)).toEqual(None());
     *
     * let x: Option<number> = None();
     * let y = Some("foo");
     * expect(x.and(y)).toEqual(None());
     *
     * let x = Some(2);
     * let y = Some("foo");
     * expect(x.and(y)).toEqual(Some("foo"));
     *
     * let x: Option<number> = None();
     * let y: Option<string> = None();
     * expect(x.and(y)).toEqual(None());
     * ```
     */
    and(optb) {
        return this.match({
            Some: () => optb,
            None: Option.None,
        });
    }
    /**
     * Maps an `Option<T>` to a promise of `Option<U>`, but only maps `Some` if
     * the state of the current Option is `Some`.
     */
    and_await(optb) {
        return this.match({
            Some: () => optb,
            None: () => Promise.resolve(Option.None()),
        });
    }
    /**
     * Returns [`None`] if the option is [`None`], otherwise calls `f` with the
     * wrapped value and returns the result.
     *
     * Some languages call this operation flatmap.
     *
     * ```
     * let sq = (x: number) => Some(x * x)
     * let nope = (_: number) => None()
     *
     * expect(Some(2).and_then(sq).and_then(sq)).toEqual(Some(16));
     * expect(Some(2).and_then(sq).and_then(nope)).toEqual(None());
     * expect(Some(2).and_then(nope).and_then(sq)).toEqual(None());
     * expect(None().and_then(sq).and_then(sq)).toEqual(None());
     * ```
     */
    and_then(fn) {
        return this.match({
            Some: fn,
            None: Option.None,
        });
    }
    /**
     * Maps an `Option<T>` to a promise of `Option<U>`, but only invokes the
     * function `Some` if the state of the current Option is `Some`.
     */
    and_then_await(fn) {
        return this.match({
            Some: fn,
            None: () => Promise.resolve(Option.None()),
        });
    }
    /**
     * Returns the option if it contains a value, otherwise returns `optb`.
     *
     * Arguments passed to `or` are eagerly evaluated; if you are passing the
     * result of a function call, it is recommended to use [`or_else`], which is
     * lazily evaluated.
     *
     * ```
     * let x = Some(2);
     * let y = None();
     * expect(x.or(y)).toEqual(Some(2));
     *
     * let x = None();
     * let y = Some(100);
     * expect(x.or(y)).toEqual(Some(100));
     *
     * let x = Some(2);
     * let y = Some(100);
     * expect(x.or(y)).toEqual(Some(2));
     *
     * let x: Option<number> = None();
     * let y = None();
     * expect(x.or(y)).toEqual(None());
     * ```
     */
    or(optb) {
        return this.match({
            Some: Option.Some,
            None: () => optb,
        });
    }
    /**
     * Unwraps the optional value, returning `null` when `None`.
     */
    or_null() {
        return this.match({
            None: () => null,
            Some: utils_1.identity,
        });
    }
    /**
     * Unwraps the optional value, returning `undefined` when `None`.
     */
    or_void() {
        return this.match({
            None: () => undefined,
            Some: utils_1.identity,
        });
    }
    /**
     * `or_await` returns the Option wrapped in a Promise if it contains a value,
     * or else returns the given promised Option.
     */
    or_await(optb) {
        return this.match({
            Some: (value) => Promise.resolve(Option.Some(value)),
            None: () => optb,
        });
    }
    /**
     * Returns the option if it contains a value, otherwise calls `fn` and
     * returns the result.
     *
     * ```
     * let nobody = () => None()
     * let vikings = () => Some("vikings")
     *
     * expect(Some("barbarians").or_else(vikings)).toEqual(Some("barbarians"));
     * expect(None().or_else(vikings)).toEqual(Some("vikings"));
     * expect(None().or_else(nobody)).toEqual(None());
     * ```
     */
    or_else(fn) {
        return this.match({
            Some: Option.Some,
            None: fn,
        });
    }
    /**
     * `or_else_await` returns the Option wrapped in a Promise if it contains a value,
     * or else calls the given function and returns its promised Option.
     */
    or_else_await(fn) {
        return this.match({
            Some: (value) => Promise.resolve(Option.Some(value)),
            None: fn,
        });
    }
    /**
     * Maps the option type to a Result type.
     * A Some value is considered an Ok,
     * while a None value is considered an Err.
     *
     * ```
     * Some(T) => Ok(T)
     * None() => Err(undefined)
     * ```
     */
    into_result() {
        return this.match({
            Some: index_1.Result.Ok,
            None: () => index_1.Result.Err(undefined),
        });
    }
    /**
     * Maps the option type to the opposite Result of `Option.into_result`.
     * A None value is considered an Ok,
     * while a Some value is considered an Err.
     *
     * This is used most commonly with a NodeJS style callback
     * containing `Error | null` as the first argument.
     *
     * ```
     * Some(T) => Err(T)
     * None() => Ok(void)
     *
     * // Promisify fs.readFile, but only resolve
     * // using the Result type.
     * // Start by consuming the err
     * // in the option to determine it's existence,
     * // then map it to an inverse Result
     * // (where Some(err) is an Err(err)),
     * // and finally map the Ok from
     * // Ok(void) => Ok(data: string)
     * let read_result = await new Promise(resolve =>
     *  fs.readFile("file.txt", "utf8", (err, data) => {
     *    resolve(Option.of(err).into_result_err().map(_ => data))
     *  })
     * )
     * // => Result<string, ErrnoException>
     * ```
     */
    into_result_err() {
        return this.into_result().invert();
    }
    toString() {
        return this.match({
            Some: (x) => `Some<${JSON.stringify(x)}>`,
            None: () => `None`,
        });
    }
    toJSON() {
        return this.match({
            Some: utils_1.identity,
            None: utils_1.always_null,
        });
    }
    /**
     * Helper to compare 2 optional types.
     *
     * The compare function defaults to
     * `(a, b) => a === b`.
     *
     * ```rust
     * match (this, option) => {
     *   (None, None) => true,
     *   (Some(a), Some(b)) => compare(a, b),
     *   _ => false
     * }
     * ```
     *
     * **Abstract Truth Table**
     *
     * - `None && None = true`
     * - `Some<T> && None = false`
     * - `None && Some<U> = false`
     * - `Some<T> && Some<U> = compare(T, U)`
     */
    is_eq(option, compare) {
        if (this.is_none() && option.is_none()) {
            return true;
        }
        if (this.is_some() && option.is_some()) {
            let a = this.unwrap();
            let b = option.unwrap();
            if (compare) {
                return compare(a, b);
            }
            return a === b;
        }
        return false;
    }
    /**
     * Given a nullable value of T (`T | undefined | null`),
     * returns an Option<T>
     */
    static from(val) {
        if (utils_1.is_void(val)) {
            return Option.None();
        }
        return Option.Some(val);
    }
    /**
     * Given a nullable value of T (`T | undefined | null`),
     * returns an Option<T>
     */
    static of(val) {
        return Option.from(val);
    }
    /**
     * Given an array shaped `Option<T>[]`, returns an Option of all the unwrapped
     * values or None.
     * Eager return (returns upon first None case).
     */
    static every(options) {
        let ok = [];
        let o;
        const matcher = {
            Some: (t) => ok.push(t),
            None: () => 0,
        };
        for (o of options) {
            if (0 == o.match(matcher)) {
                return Option.None();
            }
        }
        return Option.Some(ok);
    }
    /**
     * Given an array shaped `Option<T>[]`, returns an Option of any the unwrapped
     * values or None.
     */
    static some(options) {
        if (options.length == 0) {
            return Option.Some([]);
        }
        let ok = [];
        let o;
        const matcher = {
            Some(t) {
                ok.push(t);
            },
            None() { },
        };
        for (o of options) {
            o.match(matcher);
        }
        if (ok.length > 0) {
            return Option.Some(ok);
        }
        return Option.None();
    }
    /**
     * Creates an Option<T> from a known value T.
     */
    static Some(val) {
        return new Option(some_1.Some(val));
    }
    /**
     * Creates an Option<any> from nothing.
     */
    static None() {
        return new Option(none_1.None());
    }
}
exports.Option = Option;
//# sourceMappingURL=option.js.map