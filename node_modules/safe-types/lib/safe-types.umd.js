(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.SafeTypes = {}));
}(this, (function (exports) { 'use strict';

    (function (OptionVariant) {
        OptionVariant["None"] = "None";
        OptionVariant["Some"] = "Some";
    })(exports.OptionVariant || (exports.OptionVariant = {}));
    (function (ResultVariant) {
        ResultVariant["Err"] = "Err";
        ResultVariant["Ok"] = "Ok";
    })(exports.ResultVariant || (exports.ResultVariant = {}));

    function None() {
        return {
            variant: exports.OptionVariant.None,
        };
    }

    function Some(value) {
        return {
            value,
            variant: exports.OptionVariant.Some,
        };
    }

    function is_void(val) {
        return val == null;
    }
    function is_never(_) {
        throw new Error();
    }
    function expect_never(_, err_msg) {
        throw new Error(err_msg);
    }
    function always_true() {
        return true;
    }
    function always_false() {
        return false;
    }
    function always_null() {
        return null;
    }
    function identity(t) {
        return t;
    }
    function noop() { }

    /**
     * Option is a wrapper type for nullable values (`undefined|null`). `Option.of`
     * will consume a nullable value `T` into an `Option<T>` for conducting safe
     * operations using all the class' combinators.
     */
    class Option {
        /**
         * Warning!
         * --------
         *
         * You should never construct an Option object manually. Use the `Some` and
         * `None` helpers to create an Option object from a value or nothing.
         */
        constructor(option) {
            this.option = option;
        }
        match(matcher) {
            switch (this.option.variant) {
                default:
                    return expect_never(this.option, "invalid Option variant");
                case exports.OptionVariant.None:
                    return matcher.None();
                case exports.OptionVariant.Some:
                    return matcher.Some(this.option.value);
            }
        }
        /**
         * Returns `true` if the option is a [`Some`] value.
         *
         * ```
         * let x: Option<number> = Some(2);
         * expect(x.is_some()).toBe(true);
         *
         * let x: Option<number> = None();
         * expect(x.is_some()).toBe(false);
         * ```
         */
        is_some() {
            return this.match({
                Some: always_true,
                None: always_false,
            });
        }
        /**
         * Returns `true` if the option is a [`None`] value.
         *
         * ```
         * let x: Option<number> = Some(2);
         * expect(x.is_some()).toBe(false);
         *
         * let x: Option<number> = None();
         * expect(x.is_some()).toBe(true);
         * ```
         */
        is_none() {
            return !this.is_some();
        }
        /**
         * Returns the wrapped Some value or throws an Error
         * with the given message.
         */
        expect(msg) {
            return this.match({
                Some: identity,
                None() {
                    throw new Error(msg);
                },
            });
        }
        /**
         * Returns the wrapped Some value or throws an Error.
         */
        unwrap() {
            return this.match({
                Some: identity,
                None: () => {
                    throw new Error(`Called 'Option.unwrap()' on ${this.toString()}`);
                },
            });
        }
        /**
         * Returns the wrapped Some value or the given default.
         */
        unwrap_or(def) {
            return this.match({
                Some: identity,
                None: () => def,
            });
        }
        /**
         * Returns the wrapped Some value
         * or calls and returns the result of the given func.
         */
        unwrap_or_else(fn) {
            return this.match({
                Some: identity,
                None: fn,
            });
        }
        /**
         * Returns `None` if the option is `None`, otherwise calls `predicate`
         * with the wrapped value and returns:
         * - `Some(t)` if `predicate` returns `true` (where `t` is the wrapped
         * value), and
         * - `None` if `predicate` returns `false`.
         *
         * ```
         * let is_even = (n: number) => n % 2 == 0
         *
         * expect(None().filter(is_even)).toEqual(None());
         * expect(Some(3).filter(is_even)).toEqual(None());
         * expect(Some(4).filter(is_even)).toEqual(Some(4));
         * ```
         */
        filter(predicate) {
            return this.match({
                None: Option.None,
                Some: (value) => {
                    if (!predicate(value)) {
                        return Option.None();
                    }
                    return Option.Some(value);
                },
            });
        }
        /**
         * `narrow` accepts a TypeScript type guard to narrow the generic type
         * held within `Option<T>`.
         */
        narrow(predicate) {
            return this.match({
                None: Option.None,
                Some: (value) => {
                    if (!predicate(value)) {
                        return Option.None();
                    }
                    return Option.Some(value);
                },
            });
        }
        /**
         * Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to
         * [`Ok(v)`] and [`None`] to [`Err(err)`].
         *
         * Arguments passed to `ok_or` are eagerly evaluated; if you are passing the
         * result of a function call, it is recommended to use [`ok_or_else`], which is
         * lazily evaluated.
         *
         * ```
         * let x = Some("foo");
         * expect(x.ok_or(0)).toEqual(Ok("foo"));
         *
         * let x: Option<string> = None();
         * expect(x.ok_or(0)).toEqual(Err(0));
         * ```
         */
        ok_or(err) {
            return this.match({
                Some: Result.Ok,
                None: () => Result.Err(err),
            });
        }
        /**
         * Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to
         * [`Ok(v)`] and [`None`] to [`Err(err())`].
         *
         * ```
         * let x = Some("foo");
         * expect(x.ok_or_else(() => Err(0))).toEqual(Ok("foo"));
         *
         * let x: Option<string> = None;
         * expect(x.ok_or_else(() => Err(0)).toEqual(Err(0));
         * ```
         */
        ok_or_else(err) {
            return this.match({
                Some: Result.Ok,
                None: () => Result.Err(err()),
            });
        }
        /**
         * `tap` allows you to do side-effects with the value
         * when `Option` is `Some<T>`.
         */
        tap(fn) {
            this.match({ None: noop, Some: fn });
            return this;
        }
        /**
         * Safely transform the wrapped Some value from `T` => `U`.
         *
         * ```
         * // Transform Option<string> => Option<number>
         * Option.of(maybeStr).map(str => str.trim().length)
         * ```
         */
        map(fn) {
            return this.match({
                Some: (x) => Option.Some(fn(x)),
                None: Option.None,
            });
        }
        /**
         * `map_to` transforms the inner value when Some.
         */
        map_to(value) {
            return this.map(() => value);
        }
        /**
         * Safely transform the wrapped Some value from `T` => `U`
         * and return the transformed value or a default if wrapped value is None.
         */
        map_or(def, fn) {
            return this.match({
                Some: fn,
                None: () => def,
            });
        }
        /**
         * Safely transform the wrapped Some value from `T` => `U`
         * and return the transformed value
         * or call a func to return a default if wrapped value is None.
         */
        map_or_else(def, fn) {
            return this.match({
                Some: fn,
                None: def,
            });
        }
        /**
         * Returns [`None`] if the option is [`None`], otherwise returns `optb`.
         *
         * ```
         * let x = Some(2);
         * let y: Option<string> = None();
         * expect(x.and(y)).toEqual(None());
         *
         * let x: Option<number> = None();
         * let y = Some("foo");
         * expect(x.and(y)).toEqual(None());
         *
         * let x = Some(2);
         * let y = Some("foo");
         * expect(x.and(y)).toEqual(Some("foo"));
         *
         * let x: Option<number> = None();
         * let y: Option<string> = None();
         * expect(x.and(y)).toEqual(None());
         * ```
         */
        and(optb) {
            return this.match({
                Some: () => optb,
                None: Option.None,
            });
        }
        /**
         * Maps an `Option<T>` to a promise of `Option<U>`, but only maps `Some` if
         * the state of the current Option is `Some`.
         */
        and_await(optb) {
            return this.match({
                Some: () => optb,
                None: () => Promise.resolve(Option.None()),
            });
        }
        /**
         * Returns [`None`] if the option is [`None`], otherwise calls `f` with the
         * wrapped value and returns the result.
         *
         * Some languages call this operation flatmap.
         *
         * ```
         * let sq = (x: number) => Some(x * x)
         * let nope = (_: number) => None()
         *
         * expect(Some(2).and_then(sq).and_then(sq)).toEqual(Some(16));
         * expect(Some(2).and_then(sq).and_then(nope)).toEqual(None());
         * expect(Some(2).and_then(nope).and_then(sq)).toEqual(None());
         * expect(None().and_then(sq).and_then(sq)).toEqual(None());
         * ```
         */
        and_then(fn) {
            return this.match({
                Some: fn,
                None: Option.None,
            });
        }
        /**
         * Maps an `Option<T>` to a promise of `Option<U>`, but only invokes the
         * function `Some` if the state of the current Option is `Some`.
         */
        and_then_await(fn) {
            return this.match({
                Some: fn,
                None: () => Promise.resolve(Option.None()),
            });
        }
        /**
         * Returns the option if it contains a value, otherwise returns `optb`.
         *
         * Arguments passed to `or` are eagerly evaluated; if you are passing the
         * result of a function call, it is recommended to use [`or_else`], which is
         * lazily evaluated.
         *
         * ```
         * let x = Some(2);
         * let y = None();
         * expect(x.or(y)).toEqual(Some(2));
         *
         * let x = None();
         * let y = Some(100);
         * expect(x.or(y)).toEqual(Some(100));
         *
         * let x = Some(2);
         * let y = Some(100);
         * expect(x.or(y)).toEqual(Some(2));
         *
         * let x: Option<number> = None();
         * let y = None();
         * expect(x.or(y)).toEqual(None());
         * ```
         */
        or(optb) {
            return this.match({
                Some: Option.Some,
                None: () => optb,
            });
        }
        /**
         * Unwraps the optional value, returning `null` when `None`.
         */
        or_null() {
            return this.match({
                None: () => null,
                Some: identity,
            });
        }
        /**
         * Unwraps the optional value, returning `undefined` when `None`.
         */
        or_void() {
            return this.match({
                None: () => undefined,
                Some: identity,
            });
        }
        /**
         * `or_await` returns the Option wrapped in a Promise if it contains a value,
         * or else returns the given promised Option.
         */
        or_await(optb) {
            return this.match({
                Some: (value) => Promise.resolve(Option.Some(value)),
                None: () => optb,
            });
        }
        /**
         * Returns the option if it contains a value, otherwise calls `fn` and
         * returns the result.
         *
         * ```
         * let nobody = () => None()
         * let vikings = () => Some("vikings")
         *
         * expect(Some("barbarians").or_else(vikings)).toEqual(Some("barbarians"));
         * expect(None().or_else(vikings)).toEqual(Some("vikings"));
         * expect(None().or_else(nobody)).toEqual(None());
         * ```
         */
        or_else(fn) {
            return this.match({
                Some: Option.Some,
                None: fn,
            });
        }
        /**
         * `or_else_await` returns the Option wrapped in a Promise if it contains a value,
         * or else calls the given function and returns its promised Option.
         */
        or_else_await(fn) {
            return this.match({
                Some: (value) => Promise.resolve(Option.Some(value)),
                None: fn,
            });
        }
        /**
         * Maps the option type to a Result type.
         * A Some value is considered an Ok,
         * while a None value is considered an Err.
         *
         * ```
         * Some(T) => Ok(T)
         * None() => Err(undefined)
         * ```
         */
        into_result() {
            return this.match({
                Some: Result.Ok,
                None: () => Result.Err(undefined),
            });
        }
        /**
         * Maps the option type to the opposite Result of `Option.into_result`.
         * A None value is considered an Ok,
         * while a Some value is considered an Err.
         *
         * This is used most commonly with a NodeJS style callback
         * containing `Error | null` as the first argument.
         *
         * ```
         * Some(T) => Err(T)
         * None() => Ok(void)
         *
         * // Promisify fs.readFile, but only resolve
         * // using the Result type.
         * // Start by consuming the err
         * // in the option to determine it's existence,
         * // then map it to an inverse Result
         * // (where Some(err) is an Err(err)),
         * // and finally map the Ok from
         * // Ok(void) => Ok(data: string)
         * let read_result = await new Promise(resolve =>
         *  fs.readFile("file.txt", "utf8", (err, data) => {
         *    resolve(Option.of(err).into_result_err().map(_ => data))
         *  })
         * )
         * // => Result<string, ErrnoException>
         * ```
         */
        into_result_err() {
            return this.into_result().invert();
        }
        toString() {
            return this.match({
                Some: (x) => `Some<${JSON.stringify(x)}>`,
                None: () => `None`,
            });
        }
        toJSON() {
            return this.match({
                Some: identity,
                None: always_null,
            });
        }
        /**
         * Helper to compare 2 optional types.
         *
         * The compare function defaults to
         * `(a, b) => a === b`.
         *
         * ```rust
         * match (this, option) => {
         *   (None, None) => true,
         *   (Some(a), Some(b)) => compare(a, b),
         *   _ => false
         * }
         * ```
         *
         * **Abstract Truth Table**
         *
         * - `None && None = true`
         * - `Some<T> && None = false`
         * - `None && Some<U> = false`
         * - `Some<T> && Some<U> = compare(T, U)`
         */
        is_eq(option, compare) {
            if (this.is_none() && option.is_none()) {
                return true;
            }
            if (this.is_some() && option.is_some()) {
                let a = this.unwrap();
                let b = option.unwrap();
                if (compare) {
                    return compare(a, b);
                }
                return a === b;
            }
            return false;
        }
        /**
         * Given a nullable value of T (`T | undefined | null`),
         * returns an Option<T>
         */
        static from(val) {
            if (is_void(val)) {
                return Option.None();
            }
            return Option.Some(val);
        }
        /**
         * Given a nullable value of T (`T | undefined | null`),
         * returns an Option<T>
         */
        static of(val) {
            return Option.from(val);
        }
        /**
         * Given an array shaped `Option<T>[]`, returns an Option of all the unwrapped
         * values or None.
         * Eager return (returns upon first None case).
         */
        static every(options) {
            let ok = [];
            let o;
            const matcher = {
                Some: (t) => ok.push(t),
                None: () => 0,
            };
            for (o of options) {
                if (0 == o.match(matcher)) {
                    return Option.None();
                }
            }
            return Option.Some(ok);
        }
        /**
         * Given an array shaped `Option<T>[]`, returns an Option of any the unwrapped
         * values or None.
         */
        static some(options) {
            if (options.length == 0) {
                return Option.Some([]);
            }
            let ok = [];
            let o;
            const matcher = {
                Some(t) {
                    ok.push(t);
                },
                None() { },
            };
            for (o of options) {
                o.match(matcher);
            }
            if (ok.length > 0) {
                return Option.Some(ok);
            }
            return Option.None();
        }
        /**
         * Creates an Option<T> from a known value T.
         */
        static Some(val) {
            return new Option(Some(val));
        }
        /**
         * Creates an Option<any> from nothing.
         */
        static None() {
            return new Option(None());
        }
    }

    function Err(error) {
        return {
            error,
            variant: exports.ResultVariant.Err,
        };
    }

    function Ok(value) {
        return {
            value,
            variant: exports.ResultVariant.Ok,
        };
    }

    var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    /**
     * `Task<T, E>` represents a time-based operation that can resolve with success
     * or error value types `T` or `E` respectively.
     */
    class Task {
        /**
         * Construct a new Task by passing a function that performs the Task operation
         * itself. The function receives a `TaskResolver` object as it's first
         * argument. One of the resolver methods must be called or the Task will never
         * complete.
         */
        constructor(executor) {
            this.executor = executor;
        }
        /**
         * `fork` begins execution of the Task and returns a Promise resolving with a
         * `Result` that contains the the return value of your resolver object's
         * corresponding callback.
         */
        fork(resolver) {
            let { Ok: mapOk, Err: mapErr } = resolver;
            return new Promise((resolve) => this.executor({
                Ok: (okValue) => resolve(Result.Ok(mapOk(okValue))),
                Err: (errValue) => resolve(Result.Err(mapErr(errValue))),
            }));
        }
        /**
         * `run` begins execution of the Task and returns a Promise resolving with a
         * `Result` that contains the success or error value of the Task.
         */
        run() {
            return this.fork({
                Err: identity,
                Ok: identity,
            });
        }
        /**
         * Conforms to the Promise A+ spec.
         */
        then(onfulfilled, onrejected) {
            return this.try().then(onfulfilled, onrejected);
        }
        /**
         * `run_sync` executes the Task synchronously and returns a `Result` that
         * contains the success or error value of the Task.
         *
         * _NOTE: throws an Error if a callback is not invoked synchronously._
         */
        run_sync() {
            let r;
            // The executor is not guaranteed to return anything.
            // We need to use the callbacks to assign our Result.
            this.executor({
                Ok(value) {
                    r = Result.Ok(value);
                },
                Err(err) {
                    r = Result.Err(err);
                },
            });
            // The first bang `!` is for logical not, the second for definite assignment
            if (!r) {
                throw new Error(`Task.run_sync expects the executor to resolve synchronously.`);
            }
            // We've asserted that `r` is definitely assigned
            return r;
        }
        /**
         * `exec` immediately executes the task,
         * but discards the resolved value for both success and error cases.
         */
        exec() {
            this.executor({
                Ok: noop,
                Err: noop,
            });
        }
        /**
         * `try` runs a task and resolves with a success value,
         * or throws it's error value.
         */
        try() {
            return new Promise((Ok, Err) => {
                this.executor({ Ok, Err });
            });
        }
        /**
         * `tap` allows you to do side-effects with the value
         * when the Task is executed and is on the success path.
         *
         * Essentially a shorthand for doing a `Task.map()` that
         * returns the value it's called with after performing a side-effect.
         */
        tap(fn) {
            return this.map((ok) => {
                fn(ok);
                return ok;
            });
        }
        /**
         * `tap_err` allows you to do side-effects with the value
         * when the Task is executed and is on the error path.
         *
         * Essentially a shorthand for doing a `Task.map_err()` that
         * returns the value it's called with after performing a side-effect.
         */
        tap_err(fn) {
            return this.map_err((err) => {
                fn(err);
                return err;
            });
        }
        /**
         * `finally` allows you to run a side-effect function
         * in either Ok/Err cases, but does not receive a value.
         */
        finally(fn) {
            return new Task(({ Ok, Err }) => this.executor({
                Ok(ok) {
                    fn();
                    Ok(ok);
                },
                Err(err) {
                    fn();
                    Err(err);
                },
            }));
        }
        /**
         * `map` returns a new Task with the success value mapped according to the
         * map function given. `map` should be a synchronous operation.
         */
        map(op) {
            return new Task(({ Ok, Err }) => this.executor({
                Ok: (okValue) => Ok(op(okValue)),
                Err,
            }));
        }
        /**
         * `map_to` returns a new Task with the success value mapped to the static
         * value given.
         */
        map_to(value) {
            return this.map(() => value);
        }
        /**
         * `map_err` returns a new Task with the error value mapped according to the
         * map function given. `map` should be a synchronous operation.
         */
        map_err(op) {
            return new Task(({ Ok, Err }) => this.executor({
                Ok,
                Err: (errValue) => Err(op(errValue)),
            }));
        }
        /**
         * `map_err_to` returns a new Task with the success value mapped to the static
         * value given.
         */
        map_err_to(error) {
            return this.map_err(() => error);
        }
        /**
         * `map_both` returns a new Task that applies the map functions to either the
         * success case or the error case.
         */
        map_both(bimap) {
            return new Task(({ Ok, Err }) => this.executor({
                Ok: (okValue) => Ok(bimap.Ok(okValue)),
                Err: (errValue) => Err(bimap.Err(errValue)),
            }));
        }
        /**
         * `and` composes two Tasks such that `task_b` is forked only if the first
         * task resolves with a success. `task_b` must have the same error type as the
         * first task, but can return a new success type.
         */
        and(task_b) {
            return new Task(({ Ok, Err }) => this.executor({
                Ok: () => task_b.executor({ Ok, Err }),
                Err,
            }));
        }
        /**
         * `and_effect` will compose a Task such that the effect is only executed
         * if the first task resolves with a success. It will resolve with the
         * value of the first task and execute the effect task via `Task.exec`,
         * discarding it's return and leaving the task chain unaffected.
         */
        and_effect(effect) {
            return this.tap(() => {
                effect.exec();
            });
        }
        /**
         * `and_then` accepts a function that takes the success value of the first
         * Task and returns a new Task. This allows for sequencing tasks that depend
         * on the output of a previous task. The new Task must have the same error
         * type as the first task, but can return a new success type.
         */
        and_then(op) {
            return new Task(({ Ok, Err }) => this.executor({
                Ok: (okValue) => op(okValue).executor({ Ok, Err }),
                Err,
            }));
        }
        /**
         * `and_then_effect` will compose a Task such that the effect func is only
         * called and executed if the first task resolves with a success.
         * It will resolve with the value of the first task
         * and execute the effect task via `Task.exec`,
         * discarding it's return and leaving the task chain unaffected.
         *
         * **CAUTION:**
         * Mutating the value the effect func is called with will affect the chain.
         */
        and_then_effect(effect_fn) {
            return this.tap((x) => {
                effect_fn(x).exec();
            });
        }
        /**
         * `or` composes two Tasks such that `task_b` is forked only if the first Task
         * resolves with an error. `task_b` must have the same success type as the
         * first task, but can return a new error type.
         */
        or(task_b) {
            return new Task(({ Ok, Err }) => this.executor({
                Ok,
                Err: () => task_b.executor({ Ok, Err }),
            }));
        }
        /**
         * `or_effect` will compose a Task such that the effect is only executed
         * if the first task resolves with an error. It will resolve with the
         * value of the first task and execute the effect task via `Task.exec`,
         * discarding it's return and leaving the task chain unaffected.
         */
        or_effect(effect) {
            return this.tap_err(() => {
                effect.exec();
            });
        }
        /**
         * `or_else` accepts a function that takes the error value of the first Task
         * and returns a new Task. This allows for sequencing tasks in the case of
         * failure based on the output of a previous task. The new Task must have the
         * same success type as the first task, but can return a new error type.
         */
        or_else(op) {
            return new Task(({ Ok, Err }) => this.executor({
                Ok,
                Err: (errValue) => op(errValue).executor({ Ok, Err }),
            }));
        }
        /**
         * `or_else_effect` will compose a Task such that the effect func is only
         * called and executed if the first task resolves with an error.
         * It will resolve with the value of the first task
         * and execute the effect task via `Task.exec`,
         * discarding it's return and leaving the task chain unaffected.
         *
         * **CAUTION:**
         * Mutating the value the effect func is called with will affect the chain.
         */
        or_else_effect(effect_fn) {
            return this.tap_err((x) => {
                effect_fn(x).exec();
            });
        }
        /**
         * `invert` returns a new Task with the success and error cases swapped.
         */
        invert() {
            return new Task(({ Ok, Err }) => this.executor({
                Ok: Err,
                Err: Ok,
            }));
        }
        /**
         * Unlike `Result` and `Option` types which know their state and stringify, `Task` cannot
         * since it represent a future value. As such, it just behaves like a generic
         * object for stringify behavior:
         *
      ```
      '[object Task]'
      ```
         */
        toString() {
            return `[object Task]`;
        }
        /**
         * Construct a new Task by passing a function that performs the Task operation
         * itself. The function receives a `TaskResolver` object as it's first
         * argument. One of the resolver methods must be called or the Task will never
         * complete.
         */
        static from(executor) {
            return new Task(executor);
        }
        /**
         * Takes any number of tasks and returns a new Task that will run all tasks
         * concurrently. The first task to fail will trigger the rest to abort.
         */
        static all(tasks) {
            return new Task(({ Ok, Err }) => {
                Promise.all(tasks.map(task_all_executor)).then(Ok).catch(Err);
                function task_all_executor(t) {
                    return new Promise((resolve, reject) => t.executor({
                        Ok: resolve,
                        Err: reject,
                    }));
                }
            });
        }
        /**
         * Takes any number of tasks and returns a new Task that will run all tasks
         * with the specified concurrency.
         * The first task to fail will trigger the rest to abort.
         */
        static all_concurrent(options, tasks) {
            return new Task(({ Ok, Err }) => {
                let { concurrency } = options;
                let results = new Array(tasks.length);
                let completed = 0;
                let started = 0;
                let running = 0;
                let didError = false;
                replenish();
                function replenish() {
                    if (completed >= tasks.length) {
                        return Ok(results);
                    }
                    while (running < concurrency && started < tasks.length && !didError) {
                        running++;
                        started++;
                        worker(started - 1);
                    }
                }
                function worker(index) {
                    tasks[index]
                        .tap((ok) => {
                        running--;
                        completed++;
                        results[index] = ok;
                        replenish();
                    })
                        .tap_err((err) => {
                        didError = true;
                        Err(err);
                    })
                        .exec();
                }
            });
        }
        /**
         * `collect` returns a new Task that will run an array of Tasks concurrently,
         * collecting all resolved values in a tuple of `[T[], E[]]`.
         *
         * **NOTE:** Order is not preserved. Always resolves `Ok`.
         */
        static collect(tasks) {
            return new Task(({ Ok }) => __awaiter(this, void 0, void 0, function* () {
                let running = tasks.length;
                let oks = [];
                let errs = [];
                if (running === 0) {
                    Ok([oks, errs]);
                }
                let resolver = {
                    Ok(okValue) {
                        oks.push(okValue);
                        running--;
                        if (running === 0) {
                            Ok([oks, errs]);
                        }
                    },
                    Err(errValue) {
                        errs.push(errValue);
                        running--;
                        if (running === 0) {
                            Ok([oks, errs]);
                        }
                    },
                };
                for (let t of tasks) {
                    t.executor(resolver);
                }
            }));
        }
        /**
         * `collect_concurrent` returns a new Task that will run an array of Tasks
         * with the specified concurrency,
         * collecting all resolved values in a tuple of `[T[], E[]]`.
         *
         * **NOTE:** Order is not preserved. Always resolves `Ok`.
         */
        static collect_concurrent(options, tasks) {
            return new Task(({ Ok }) => {
                let { concurrency } = options;
                let successes = [];
                let errors = [];
                let completed = 0;
                let started = 0;
                let running = 0;
                let resolver = {
                    Ok(okValue) {
                        successes.push(okValue);
                        running--;
                        completed++;
                        replenish();
                    },
                    Err(errValue) {
                        errors.push(errValue);
                        running--;
                        completed++;
                        replenish();
                    },
                };
                replenish();
                function replenish() {
                    if (completed >= tasks.length) {
                        return Ok([successes, errors]);
                    }
                    while (running < concurrency && started < tasks.length) {
                        running++;
                        started++;
                        worker(tasks[started - 1]);
                    }
                }
                function worker(t) {
                    t.executor(resolver);
                }
            });
        }
        /**
         * `of_ok` constructs a Task that resolves with a success of the given value.
         */
        static of_ok(okValue) {
            return new Task(({ Ok }) => Ok(okValue));
        }
        /**
         * `of_err` constructs a Task that resolves with an error of the given value.
         */
        static of_err(errValue) {
            return new Task(({ Err }) => Err(errValue));
        }
        /**
         * Wraps a Task in another Task that will be run until success
         * up to the given limit of tries.
         */
        static retry(tryLimit, task) {
            if (tryLimit < 1 || !Number.isInteger(tryLimit)) {
                throw new RangeError(`Task.retry must use an integer try limit greater than zero`);
            }
            if (tryLimit === 1) {
                return task;
            }
            return new Task(({ Ok, Err }) => __awaiter(this, void 0, void 0, function* () {
                let r;
                for (let i = 0; i < tryLimit; i++) {
                    r = yield task.run();
                    if (r.is_ok()) {
                        break;
                    }
                }
                r.match({ Ok, Err });
            }));
        }
        /**
         * Wraps a Task in another Task that will be run until success
         * up to the given limit of tries. After a failed run, exponential backoff
         * is calculated to wait before the next run. Uses exponential backoff
         * with equal jitter.
         */
        static retryWithBackoff(options, task) {
            let { msBackoffCap, tryLimit, msBackoffStep } = options;
            if (tryLimit < 1 || !Number.isInteger(tryLimit)) {
                throw new RangeError(`Task.retry must use an integer retry number greater than zero`);
            }
            if (tryLimit === 1) {
                return task;
            }
            function* backoff() {
                let retries = tryLimit - 1;
                for (let i = 0; i < retries; i++) {
                    let equalBackoff = Math.min(msBackoffCap, msBackoffStep * Math.pow(2, i)) / 2;
                    let jitter = Math.random() * equalBackoff;
                    yield equalBackoff + jitter;
                }
            }
            return new Task(({ Ok, Err }) => __awaiter(this, void 0, void 0, function* () {
                let r = yield task.run();
                if (r.is_ok()) {
                    return Ok(r.unwrap());
                }
                for (let ms of backoff()) {
                    yield new Promise((next) => setTimeout(next, ms));
                    r = yield task.run();
                    if (r.is_ok()) {
                        break;
                    }
                }
                r.match({ Ok, Err });
            }));
        }
    }

    var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    /**
     * Result is a wrapper type for operations that can succeed or fail.
     * Not all operations throw errors in failure cases. Any value can be an Err.
     * Result simultaneously holds either an `Ok` that holds any type
     * and and `Err` that also can hold any type.
     */
    class Result {
        /**
         * Warning!
         * --------
         *
         * You should never construct a Result object manually. Use the `Ok` and `Err`
         * helpers to create a Result object from a value.
         */
        constructor(result) {
            this.result = result;
        }
        /**
         * Perform a pseudo pattern match on the underlying Ok or Err type.
         * Matches the type and then returns the value of calling the matcher's
         * function with the value.
         */
        match(matcher) {
            switch (this.result.variant) {
                default:
                    return expect_never(this.result, "Invalid `Result` variant");
                case exports.ResultVariant.Ok:
                    return matcher.Ok(this.result.value);
                case exports.ResultVariant.Err:
                    return matcher.Err(this.result.error);
            }
        }
        /**
         * Returns true if the underlying type is an Ok.
         *
         * ```
         * let result = Ok(2)
         * result.is_ok()
         * // => true
         * ```
         */
        is_ok() {
            return this.match({
                Ok: always_true,
                Err: always_false,
            });
        }
        /**
         * Returns true if the underlying type is an Err.
         *
         * ```
         * let result = Ok(2)
         * result.is_err()
         * // => false
         * ```
         */
        is_err() {
            return !this.is_ok();
        }
        /**
         * Returns an Option of the Ok type.
         *
         * ```
         * let read_result: Result<string, Error> = readFileSync("foo.txt")
         * read_result.ok()
         * // => Option<string>
         * ```
         */
        ok() {
            return this.match({
                Ok: Option.Some,
                Err: Option.None,
            });
        }
        /**
         * Returns an Option of the Err type.
         *
         * ```
         * let read_result: Result<string, Error> = readFileSync("foo.txt")
         * read_result.err()
         * // => Option<Error>
         * ```
         */
        err() {
            return this.match({
                Ok: Option.None,
                Err: Option.Some,
            });
        }
        /**
         * Converts a result to a Task.
         * When the Result is Ok, forking the Task yields the Ok value.
         * When the Result is Err, forking the Task yields the Err value.
         */
        task() {
            return this.match({
                Ok: Task.of_ok,
                Err: Task.of_err,
            });
        }
        /**
         * `tap` allows you to do side-effects with the value
         * when `Result` is `Ok<T>`.
         */
        tap(fn) {
            this.match({ Err: noop, Ok: fn });
            return this;
        }
        /**
         * `tap_err` allows you to do side-effects with the value
         * when `Result` is `Err<E>`.
         */
        tap_err(fn) {
            this.match({ Err: fn, Ok: noop });
            return this;
        }
        /**
         * Perform a transformation on the possible Ok type.
         *
         * ```
         * let read_result: Result<string, Error> = readFileSync("foo.txt")
         * read_result.map(str => str.length)
         * // => Result<number, Error>
         * ```
         */
        map(op) {
            return this.match({
                Ok: (t) => Result.Ok(op(t)),
                Err: Result.Err,
            });
        }
        /**
         * `map_to` converts the inner value when Ok.
         */
        map_to(value) {
            return this.map(() => value);
        }
        /**
         * Perform a transformation on the possible Err type.
         *
         * ```
         * let read_result: Result<string, Error> = readFileSync("foo.txt")
         * read_result.map_err(err => err.message)
         * // => Result<string, string>
         * ```
         */
        map_err(op) {
            return this.match({
                Ok: Result.Ok,
                Err: (e) => Result.Err(op(e)),
            });
        }
        /**
         * `map_err_to` converts the inner value when Err.
         */
        map_err_to(error) {
            return this.map_err(() => error);
        }
        /**
         * Perform transformations on both of the possible types.
         *
         * ```
         * let read_result: Result<string, Error> = readFileSync("foo.txt")
         * read_result.map_both(console.log, console.error)
         * // => Result<void, void>
         * // => prints to stdout/stderr
         * ```
         */
        map_both(ok_op, err_op) {
            return this.match({
                Ok: (t) => Result.Ok(ok_op(t)),
                Err: (e) => Result.Err(err_op(e)),
            });
        }
        /**
         * Swaps the result's Ok type with the given result if Ok.
         *
         * ```
         * let read_result: Result<string, Error> = readFileSync("foo.txt")
         * read_result.and(readFileSync("bar.txt"))
         * // => Result<string, Error>
         * ```
         */
        and(res) {
            return this.match({
                Ok: () => res,
                Err: Result.Err,
            });
        }
        /**
         * Swaps the result's Ok type with the given Promised result if Ok
         * and normalizes the possible Err type to a Promised Err.
         *
         * ```
         * let read_result: Result<string, Error> = readFileSync("foo.txt")
         * read_result.and_await(readFile("bar.txt"))
         * // => Promise<Result<string, Error>>
         * ```
         */
        and_await(res) {
            return this.match({
                Ok: () => res,
                Err: (e) => Promise.resolve(Result.Err(e)),
            });
        }
        /**
         * Calls the given operation and swaps the Ok type if Ok.
         *
         * ```
         * let read_result: Result<string, Error> = readFileSync("foo.txt")
         * read_result.and_then(contents => readFileSync(contents.match(/\.txt$/)[1]))
         * // => Result<string, Error>
         * ```
         */
        and_then(op) {
            return this.match({
                Ok: (t) => op(t),
                Err: Result.Err,
            });
        }
        /**
         * Calls the given operation and swaps the Ok type with the promised Ok.
         * Err type is converted to a Promised Err.
         *
         *
         * ```
         * let read_result: Result<string, Error> = readFileSync("foo.txt")
         * read_result.and_then(contents => readFile(contents.match(/\.txt$/)[1]))
         * // => Promise<Result<string, Error>>
         * ```
         */
        and_then_await(op) {
            return this.match({
                Ok: op,
                Err: (e) => Promise.resolve(Result.Err(e)),
            });
        }
        /**
         * Returns `res` if the result is [`Err`],
         * otherwise returns the [`Ok`] value of `self`.
         *
         * Arguments passed to `or` are eagerly evaluated; if you are passing the
         * result of a function call, it is recommended to use [`or_else`], which is
         * lazily evaluated.
         *
         * ```
         * let x = Ok(2);
         * let y = Err("late error");
         * expect(x.or(y)).toEqual(Ok(2));
         *
         * let x = Err("early error");
         * let y = Ok(2);
         * expect(x.or(y)).toEqual(Ok(2));
         *
         * let x = Err("not a 2");
         * let y = Err("late error");
         * expect(x.or(y)).toEqual(Err("late error"));
         *
         * let x = Ok(2);
         * let y = Ok(100);
         * expect(x.or(y)).toEqual(Ok(2));
         * ```
         */
        or(res) {
            return this.match({
                Ok: Result.Ok,
                Err: () => res,
            });
        }
        /**
         * Returns the given promised result if the result an Err, or else wraps the
         * existing result in a promise.
         */
        or_await(res) {
            return this.match({
                Ok: (val) => Promise.resolve(Result.Ok(val)),
                Err: () => res,
            });
        }
        /**
         * Calls `op` if the result is [`Err`],
         * otherwise returns the [`Ok`] value of `self`.
         *
         * This function can be used for control flow based on result values.
         *
         * ```
         * let sq = (x: number) => Ok(x * x)
         * let err = (x: number) => Err(x)
         *
         * expect(Ok(2).or_else(sq).or_else(sq)).toEqual(Ok(2));
         * expect(Ok(2).or_else(err).or_else(sq)).toEqual(Ok(2));
         * expect(Err(3).or_else(sq).or_else(err)).toEqual(Ok(9));
         * expect(Err(3).or_else(err).or_else(err)).toEqual(Err(3));
         * ```
         */
        or_else(op) {
            return this.match({
                Ok: Result.Ok,
                Err: op,
            });
        }
        /**
         * Calls the given function if the result an Err, or else wraps the
         * existing result in a promise.
         */
        or_else_await(op) {
            return this.match({
                Ok: (val) => Promise.resolve(Result.Ok(val)),
                Err: op,
            });
        }
        /**
         * Unwraps a result, yielding the content of an [`Ok`].
         * Else, it returns `optb`.
         *
         * Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing
         * the result of a function call, it is recommended to use [`unwrap_or_else`],
         * which is lazily evaluated.
         *
         * ```
         * let optb = 2;
         * let x: Result<number, string> = Ok(9);
         * expect(x.unwrap_or(optb)).toEqual(9);
         *
         * let x: Result<number, string> = Err("error");
         * expect(x.unwrap_or(optb)).toEqual(optb);
         * ```
         */
        unwrap_or(optb) {
            return this.match({
                Ok: identity,
                Err: () => optb,
            });
        }
        /**
         * Unwraps a result, yielding the content of an [`Ok`].
         * If the value is an [`Err`] then it calls `op` with its value.
         *
         * ```
         * let count = (x: string) => x.length;
         *
         * expect(Ok(2).unwrap_or_else(count)).toEqual(2);
         * expect(Err("foo").unwrap_or_else(count)).toEqual(3);
         * ```
         */
        unwrap_or_else(op) {
            return this.match({
                Ok: identity,
                Err: op,
            });
        }
        /**
         * Returns the Ok type, or throws an Error.
         */
        unwrap() {
            return this.match({
                Ok: identity,
                Err: () => {
                    throw new Error(`Called 'Result.unwrap()' on ${this.toString()}`);
                },
            });
        }
        /**
         * Returns the Err type, or throws an Error.
         */
        unwrap_err() {
            return this.match({
                Ok: () => {
                    throw new Error(`Called 'Result.unwrap_err()' on ${this.toString()}`);
                },
                Err: identity,
            });
        }
        /**
         * Returns the Ok type, or throws an Error with the given message.
         */
        expect(msg) {
            return this.match({
                Ok: identity,
                Err() {
                    throw new Error(msg);
                },
            });
        }
        /**
         * Returns the Ok type, or throws the raw Err value.
         */
        try() {
            return this.match({
                Ok: identity,
                Err(error) {
                    throw error;
                },
            });
        }
        /**
         * Returns the Err type, or throws an Error with the given message.
         */
        expect_err(msg) {
            return this.match({
                Ok() {
                    throw new Error(msg);
                },
                Err: identity,
            });
        }
        /**
         * Remaps the result types so the `Ok<T>` becomes `Err<T>`
         * and the `Err<E>` becomes `Ok<E>`
         */
        invert() {
            return this.match({
                Ok: Result.Err,
                Err: Result.Ok,
            });
        }
        toString() {
            return this.match({
                Ok: (t) => `Ok<${JSON.stringify(t)}>`,
                Err: (e) => `Err<${JSON.stringify(e)}>`,
            });
        }
        /**
         * Returns an Ok result of the given type.
         */
        static Ok(val) {
            return new Result(Ok(val));
        }
        /**
         * Returns an Err result of the given type.
         */
        static Err(err) {
            return new Result(Err(err));
        }
        /**
         * Calls the operation and returns an Ok result
         * or an Err result if an Error is thrown.
         */
        static from(op) {
            try {
                return Result.Ok(op());
            }
            catch (e) {
                return Result.Err(e);
            }
        }
        /**
         * Calls the operation and returns an Ok result
         * or an Err result if an Error is thrown.
         */
        static of(op) {
            return Result.from(op);
        }
        /**
         * Given an array shaped `Result<T, E>[]`, returns a Result of all the
         * unwrapped values or the first Err.
         * Eager return (returns upon first Err case).
         */
        static every(results) {
            let r;
            let ok = [];
            let error;
            const matcher = {
                Ok: (t) => ok.push(t),
                Err: (e) => {
                    error = e;
                    return 0;
                },
            };
            for (r of results) {
                if (0 == r.match(matcher)) {
                    return Result.Err(error);
                }
            }
            return Result.Ok(ok);
        }
        /**
         * Given an array shaped `Result<T, E>[]`, returns a Result of any the
         * unwrapped values or an Err with the all of the Err values.
         */
        static some(results) {
            if (results.length == 0) {
                return Result.Ok([]);
            }
            let ok = [];
            let err = [];
            let r;
            const matcher = {
                Ok: (t) => ok.push(t),
                Err: (e) => err.push(e),
            };
            for (r of results) {
                r.match(matcher);
            }
            // Any Ok's triggers a success.
            if (ok.length > 0) {
                return Result.Ok(ok);
            }
            return Result.Err(err);
        }
        /**
         * Awaits the Promise and returns a Promised Ok result
         * or a Promised Err result if an Error is thrown.
         */
        static await(p) {
            return Promise.resolve(p).then(Result.Ok, Result.Err);
        }
        /**
         * Calls the async operation and returns a Promised Ok result
         * or a Promised Err result if an Error is thrown.
         */
        static await_fn(op) {
            try {
                return Promise.resolve(op()).then(Result.Ok, Result.Err);
            }
            catch (error) {
                return Promise.resolve(Result.Err(error));
            }
        }
        /**
         * Awaits an array of Promises and returns a Promised Ok result
         * or a Promised Err result if an Error is thrown.
         */
        static await_all(ps) {
            return __awaiter$1(this, void 0, void 0, function* () {
                return Promise.all(ps).then(Result.Ok, Result.Err);
            });
        }
        /**
         * Calls the async operation and returns a Promised Ok result
         * or a Promised Err result if an Error is thrown.
         */
        static await_all_fn(op) {
            try {
                return Promise.all(op()).then(Result.Ok, Result.Err);
            }
            catch (error) {
                return Promise.resolve(Result.Err(error));
            }
        }
    }

    function get_at_path(obj, path) {
        return path.reduce((opt, key) => opt.and_then(obj => Option.of(obj[key])), Option.of(obj));
    }
    function has_at_path(obj, path) {
        return get_at_path(obj, path).is_some();
    }
    function err_or_ok(err, ok) {
        return Option.of(err).match({
            Some(err) {
                return Result.Err(err);
            },
            None() {
                return Result.Ok(ok);
            },
        });
    }

    const { Some: Some$1, None: None$1 } = Option;
    const { Ok: Ok$1, Err: Err$1 } = Result;

    exports.Err = Err$1;
    exports.None = None$1;
    exports.Ok = Ok$1;
    exports.Option = Option;
    exports.Result = Result;
    exports.Some = Some$1;
    exports.Task = Task;
    exports.err_or_ok = err_or_ok;
    exports.expect_never = expect_never;
    exports.get_at_path = get_at_path;
    exports.has_at_path = has_at_path;
    exports.is_never = is_never;
    exports.is_void = is_void;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
