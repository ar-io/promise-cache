import { Err } from "./err";
import { Option } from "./index";
import { Ok } from "./ok";
import { Mapper } from "./utils";
import { Task } from "./task";
export declare type ResultType<OkType, ErrType> = Ok<OkType> | Err<ErrType>;
export interface ResultMatcher<OkType, ErrType, Output> {
    Ok(x: OkType): Output;
    Err(e: ErrType): Output;
}
export declare type UnwrapResultOk<R> = R extends Result<infer T, any> ? T : never;
export declare type UnwrapResultErr<R> = R extends Result<any, infer E> ? E : never;
/**
 * Result is a wrapper type for operations that can succeed or fail.
 * Not all operations throw errors in failure cases. Any value can be an Err.
 * Result simultaneously holds either an `Ok` that holds any type
 * and and `Err` that also can hold any type.
 */
export declare class Result<OkType, ErrType> {
    readonly result: ResultType<OkType, ErrType>;
    /**
     * Warning!
     * --------
     *
     * You should never construct a Result object manually. Use the `Ok` and `Err`
     * helpers to create a Result object from a value.
     */
    constructor(result: ResultType<OkType, ErrType>);
    /**
     * Perform a pseudo pattern match on the underlying Ok or Err type.
     * Matches the type and then returns the value of calling the matcher's
     * function with the value.
     */
    match<Output>(matcher: ResultMatcher<OkType, ErrType, Output>): Output;
    /**
     * Returns true if the underlying type is an Ok.
     *
     * ```
     * let result = Ok(2)
     * result.is_ok()
     * // => true
     * ```
     */
    is_ok(): this is {
        result: Ok<OkType>;
    };
    /**
     * Returns true if the underlying type is an Err.
     *
     * ```
     * let result = Ok(2)
     * result.is_err()
     * // => false
     * ```
     */
    is_err(): this is {
        result: Err<ErrType>;
    };
    /**
     * Returns an Option of the Ok type.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.ok()
     * // => Option<string>
     * ```
     */
    ok(): Option<OkType>;
    /**
     * Returns an Option of the Err type.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.err()
     * // => Option<Error>
     * ```
     */
    err(): Option<ErrType>;
    /**
     * Converts a result to a Task.
     * When the Result is Ok, forking the Task yields the Ok value.
     * When the Result is Err, forking the Task yields the Err value.
     */
    task(): Task<OkType, ErrType>;
    /**
     * `tap` allows you to do side-effects with the value
     * when `Result` is `Ok<T>`.
     */
    tap(fn: (ok: OkType) => any): this;
    /**
     * `tap_err` allows you to do side-effects with the value
     * when `Result` is `Err<E>`.
     */
    tap_err(fn: (err: ErrType) => any): this;
    /**
     * Perform a transformation on the possible Ok type.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.map(str => str.length)
     * // => Result<number, Error>
     * ```
     */
    map<MappedOk>(op: Mapper<OkType, MappedOk>): Result<MappedOk, ErrType>;
    /**
     * `map_to` converts the inner value when Ok.
     */
    map_to<OkVal>(value: OkVal): Result<OkVal, ErrType>;
    /**
     * Perform a transformation on the possible Err type.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.map_err(err => err.message)
     * // => Result<string, string>
     * ```
     */
    map_err<MappedErr>(op: Mapper<ErrType, MappedErr>): Result<OkType, MappedErr>;
    /**
     * `map_err_to` converts the inner value when Err.
     */
    map_err_to<ErrVal>(error: ErrVal): Result<OkType, ErrVal>;
    /**
     * Perform transformations on both of the possible types.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.map_both(console.log, console.error)
     * // => Result<void, void>
     * // => prints to stdout/stderr
     * ```
     */
    map_both<MappedOk, MappedErr>(ok_op: Mapper<OkType, MappedOk>, err_op: Mapper<ErrType, MappedErr>): Result<MappedOk, MappedErr>;
    /**
     * Swaps the result's Ok type with the given result if Ok.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.and(readFileSync("bar.txt"))
     * // => Result<string, Error>
     * ```
     */
    and<NextOkType>(res: Result<NextOkType, ErrType>): Result<NextOkType, ErrType>;
    /**
     * Swaps the result's Ok type with the given Promised result if Ok
     * and normalizes the possible Err type to a Promised Err.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.and_await(readFile("bar.txt"))
     * // => Promise<Result<string, Error>>
     * ```
     */
    and_await<NextOkType>(res: Promise<Result<NextOkType, ErrType>>): Promise<Result<NextOkType, ErrType>>;
    /**
     * Calls the given operation and swaps the Ok type if Ok.
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.and_then(contents => readFileSync(contents.match(/\.txt$/)[1]))
     * // => Result<string, Error>
     * ```
     */
    and_then<NextOkType>(op: (t: OkType) => Result<NextOkType, ErrType>): Result<NextOkType, ErrType>;
    /**
     * Calls the given operation and swaps the Ok type with the promised Ok.
     * Err type is converted to a Promised Err.
     *
     *
     * ```
     * let read_result: Result<string, Error> = readFileSync("foo.txt")
     * read_result.and_then(contents => readFile(contents.match(/\.txt$/)[1]))
     * // => Promise<Result<string, Error>>
     * ```
     */
    and_then_await<NextOkType>(op: (t: OkType) => Promise<Result<NextOkType, ErrType>>): Promise<Result<NextOkType, ErrType>>;
    /**
     * Returns `res` if the result is [`Err`],
     * otherwise returns the [`Ok`] value of `self`.
     *
     * Arguments passed to `or` are eagerly evaluated; if you are passing the
     * result of a function call, it is recommended to use [`or_else`], which is
     * lazily evaluated.
     *
     * ```
     * let x = Ok(2);
     * let y = Err("late error");
     * expect(x.or(y)).toEqual(Ok(2));
     *
     * let x = Err("early error");
     * let y = Ok(2);
     * expect(x.or(y)).toEqual(Ok(2));
     *
     * let x = Err("not a 2");
     * let y = Err("late error");
     * expect(x.or(y)).toEqual(Err("late error"));
     *
     * let x = Ok(2);
     * let y = Ok(100);
     * expect(x.or(y)).toEqual(Ok(2));
     * ```
     */
    or<NextErrType>(res: Result<OkType, NextErrType>): Result<OkType, NextErrType>;
    /**
     * Returns the given promised result if the result an Err, or else wraps the
     * existing result in a promise.
     */
    or_await<NextErrType>(res: Promise<Result<OkType, NextErrType>>): Promise<Result<OkType, NextErrType>>;
    /**
     * Calls `op` if the result is [`Err`],
     * otherwise returns the [`Ok`] value of `self`.
     *
     * This function can be used for control flow based on result values.
     *
     * ```
     * let sq = (x: number) => Ok(x * x)
     * let err = (x: number) => Err(x)
     *
     * expect(Ok(2).or_else(sq).or_else(sq)).toEqual(Ok(2));
     * expect(Ok(2).or_else(err).or_else(sq)).toEqual(Ok(2));
     * expect(Err(3).or_else(sq).or_else(err)).toEqual(Ok(9));
     * expect(Err(3).or_else(err).or_else(err)).toEqual(Err(3));
     * ```
     */
    or_else<NextErrType>(op: (e: ErrType) => Result<OkType, NextErrType>): Result<OkType, NextErrType>;
    /**
     * Calls the given function if the result an Err, or else wraps the
     * existing result in a promise.
     */
    or_else_await<NextErrType>(op: (e: ErrType) => Promise<Result<OkType, NextErrType>>): Promise<Result<OkType, NextErrType>>;
    /**
     * Unwraps a result, yielding the content of an [`Ok`].
     * Else, it returns `optb`.
     *
     * Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing
     * the result of a function call, it is recommended to use [`unwrap_or_else`],
     * which is lazily evaluated.
     *
     * ```
     * let optb = 2;
     * let x: Result<number, string> = Ok(9);
     * expect(x.unwrap_or(optb)).toEqual(9);
     *
     * let x: Result<number, string> = Err("error");
     * expect(x.unwrap_or(optb)).toEqual(optb);
     * ```
     */
    unwrap_or(optb: OkType): OkType;
    /**
     * Unwraps a result, yielding the content of an [`Ok`].
     * If the value is an [`Err`] then it calls `op` with its value.
     *
     * ```
     * let count = (x: string) => x.length;
     *
     * expect(Ok(2).unwrap_or_else(count)).toEqual(2);
     * expect(Err("foo").unwrap_or_else(count)).toEqual(3);
     * ```
     */
    unwrap_or_else(op: (e: ErrType) => OkType): OkType;
    /**
     * Returns the Ok type, or throws an Error.
     */
    unwrap(): OkType;
    /**
     * Returns the Err type, or throws an Error.
     */
    unwrap_err(): ErrType;
    /**
     * Returns the Ok type, or throws an Error with the given message.
     */
    expect(msg: string): OkType;
    /**
     * Returns the Ok type, or throws the raw Err value.
     */
    try(): OkType;
    /**
     * Returns the Err type, or throws an Error with the given message.
     */
    expect_err(msg: string): ErrType;
    /**
     * Remaps the result types so the `Ok<T>` becomes `Err<T>`
     * and the `Err<E>` becomes `Ok<E>`
     */
    invert(): Result<ErrType, OkType>;
    toString(): string;
    /**
     * Returns an Ok result of the given type.
     */
    static Ok<OkType, ErrType = any>(val: OkType): Result<OkType, ErrType>;
    /**
     * Returns an Err result of the given type.
     */
    static Err<ErrType, OkType = any>(err: ErrType): Result<OkType, ErrType>;
    /**
     * Calls the operation and returns an Ok result
     * or an Err result if an Error is thrown.
     */
    static from<OkType, ErrType>(op: () => OkType): Result<OkType, ErrType>;
    /**
     * Calls the operation and returns an Ok result
     * or an Err result if an Error is thrown.
     */
    static of<OkType, ErrType>(op: () => OkType): Result<OkType, ErrType>;
    /**
     * Given an array shaped `Result<T, E>[]`, returns a Result of all the
     * unwrapped values or the first Err.
     * Eager return (returns upon first Err case).
     */
    static every<OkType, ErrType>(results: Result<OkType, ErrType>[]): Result<OkType[], ErrType>;
    /**
     * Given an array shaped `Result<T, E>[]`, returns a Result of any the
     * unwrapped values or an Err with the all of the Err values.
     */
    static some<OkType, ErrType>(results: Result<OkType, ErrType>[]): Result<OkType[], ErrType[]>;
    /**
     * Awaits the Promise and returns a Promised Ok result
     * or a Promised Err result if an Error is thrown.
     */
    static await<OkType, ErrType>(p: Promise<OkType>): Promise<Result<OkType, ErrType>>;
    /**
     * Calls the async operation and returns a Promised Ok result
     * or a Promised Err result if an Error is thrown.
     */
    static await_fn<OkType, ErrType>(op: () => Promise<OkType>): Promise<Result<OkType, ErrType>>;
    /**
     * Awaits an array of Promises and returns a Promised Ok result
     * or a Promised Err result if an Error is thrown.
     */
    static await_all<OkType, ErrType>(ps: Array<Promise<OkType>>): Promise<Result<OkType[], ErrType>>;
    /**
     * Calls the async operation and returns a Promised Ok result
     * or a Promised Err result if an Error is thrown.
     */
    static await_all_fn<OkType, ErrType>(op: () => Array<Promise<OkType>>): Promise<Result<OkType[], ErrType>>;
}
